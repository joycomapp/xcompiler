//****************************************************************
//   CPLUS2\SCAN_C.FRM
//   Coco/R C++ Support Frames.
//   Author: Frankie Arzu <farzu@uvg.edu.gt>
//
//   Jun 12, 1996  Version 1.06
//      Many fixes and suggestions thanks to
//      Pat Terry <p.terry@.ru.ac.za>
//   Oct 31, 1999  Version 1.14
//      LeftContext Support
//   Mar 24, 2000  Version 1.15
//      LeftContext Support no longer needed
//****************************************************************

/*************** NOTICE *****************
	This file is generated by cocoR       
*****************************************/
	
//#include "cc.hpp"
#include "cs.hpp"
//
#define Scan_Ch        Ch
#define Scan_NextCh    NextCh
#define Scan_ComEols   ComEols
#define Scan_CurrLine  CurrLine
#define Scan_CurrCol   CurrCol
#define Scan_LineStart LineStart
#define Scan_BuffPos   BuffPos
#define Scan_NextLen   NextSym.Len

int cScanner::STATE0[] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,24,89,17,29,0,74,61,13,36,37,41,50,42,59,40,90,32,1,1,1,1,1,1,1,1,1,23,58,
                  91,38,67,51,45,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,
                  26,54,0,55,63,26,14,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,
                  26,26,26,0,21,0,43,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};

int cScanner::CheckLiteral(int id)
{ char c;
  c =  CurrentCh(NextSym.Pos);
  if (IgnoreCase) c = Upcase(c);
  switch (c) {
  	case 'A':
  		if (EqualStr("ACTIVATION")) return C_ACTIVATIONSym;
  		if (EqualStr("AS")) return C_ASSym;
  		if (EqualStr("ASCENDING")) return C_ASCENDINGSym;
  		if (EqualStr("APPENDING")) return C_APPENDINGSym;
  		if (EqualStr("APPEND")) return C_APPENDSym;
  		if (EqualStr("AT")) return C_ATSym;
  		if (EqualStr("ABBREVIATED")) return C_ABBREVIATEDSym;
  		if (EqualStr("AND")) return C_ANDSym;
  		if (EqualStr("ALIAS")) return C_ALIASSym;
  		if (EqualStr("ADJACENT")) return C_ADJACENTSym;
  		if (EqualStr("ACTUAL")) return C_ACTUALSym;
  		if (EqualStr("ARCHIVE")) return C_ARCHIVESym;
  		if (EqualStr("ASSOCIATION")) return C_ASSOCIATIONSym;
  		if (EqualStr("ABSTRACT")) return C_ABSTRACTSym;
  		if (EqualStr("ANY")) return C_ANYSym;
  		if (EqualStr("ADD")) return C_ADDSym;
  		if (EqualStr("ACCORDING")) return C_ACCORDINGSym;
  		if (EqualStr("ALIASES")) return C_ALIASESSym;
  		if (EqualStr("ASSERT")) return C_ASSERTSym;
  		if (EqualStr("ASSIGN")) return C_ASSIGNSym;
  		if (EqualStr("AREA")) return C_AREASym;
  		if (EqualStr("ATTRIBUTES")) return C_ATTRIBUTESSym;
  		if (EqualStr("ACCEPTING")) return C_ACCEPTINGSym;
  		if (EqualStr("ARITHMETIC")) return C_ARITHMETICSym;
  		if (EqualStr("ANALYZER")) return C_ANALYZERSym;
  		if (EqualStr("ASYNCHRONOUS")) return C_ASYNCHRONOUSSym;
  		if (EqualStr("ASSIGNED")) return C_ASSIGNEDSym;
  		if (EqualStr("ALL")) return C_ALLSym;
  		if (EqualStr("ASSIGNING")) return C_ASSIGNINGSym;
  		if (EqualStr("AUTHORITY-CHECK")) return C_AUTHORITYMinusCHECKSym;
  		if (EqualStr("ADD-CORRESPONDING")) return C_ADDMinusCORRESPONDINGSym;
  		break;
  	case 'B':
  		if (EqualStr("BOXED")) return C_BOXEDSym;
  		if (EqualStr("BY")) return C_BYSym;
  		if (EqualStr("BLOB")) return C_BLOBSym;
  		if (EqualStr("BYPASSING")) return C_BYPASSINGSym;
  		if (EqualStr("BUFFER")) return C_BUFFERSym;
  		if (EqualStr("BYTE")) return C_BYTESym;
  		if (EqualStr("BLANKS")) return C_BLANKSSym;
  		if (EqualStr("BEGIN")) return C_BEGINSym;
  		if (EqualStr("BETWEEN")) return C_BETWEENSym;
  		if (EqualStr("BIG")) return C_BIGSym;
  		if (EqualStr("BOUNDS")) return C_BOUNDSSym;
  		if (EqualStr("BEFORE")) return C_BEFORESym;
  		if (EqualStr("BASE")) return C_BASESym;
  		if (EqualStr("BACKGROUND")) return C_BACKGROUNDSym;
  		if (EqualStr("BACK")) return C_BACKSym;
  		if (EqualStr("BADI")) return C_BADISym;
  		if (EqualStr("BACKUP")) return C_BACKUPSym;
  		if (EqualStr("BIT")) return C_BITSym;
  		if (EqualStr("BOUNDARIES")) return C_BOUNDARIESSym;
  		if (EqualStr("BACKWARD")) return C_BACKWARDSym;
  		if (EqualStr("BLANK")) return C_BLANKSym;
  		if (EqualStr("BOUND")) return C_BOUNDSym;
  		if (EqualStr("BINARY")) return C_BINARYSym;
  		if (EqualStr("BYTE-ORDER")) return C_BYTEMinusORDERSym;
  		if (EqualStr("BREAK-POINT")) return C_BREAKMinusPOINTSym;
  		if (EqualStr("BYTE-CO")) return C_BYTEMinusCOSym;
  		if (EqualStr("BYTE-CN")) return C_BYTEMinusCNSym;
  		if (EqualStr("BYTE-CA")) return C_BYTEMinusCASym;
  		if (EqualStr("BYTE-NA")) return C_BYTEMinusNASym;
  		if (EqualStr("BYTE-CS")) return C_BYTEMinusCSSym;
  		if (EqualStr("BYTE-NS")) return C_BYTEMinusNSSym;
  		break;
  	case 'C':
  		if (EqualStr("CREATE")) return C_CREATESym;
  		if (EqualStr("COMPONENTS")) return C_COMPONENTSSym;
  		if (EqualStr("CLIENT")) return C_CLIENTSym;
  		if (EqualStr("CROSS")) return C_CROSSSym;
  		if (EqualStr("CORRESPONDING")) return C_CORRESPONDINGSym;
  		if (EqualStr("CREATING")) return C_CREATINGSym;
  		if (EqualStr("COLUMNS")) return C_COLUMNSSym;
  		if (EqualStr("CLOB")) return C_CLOBSym;
  		if (EqualStr("CONNECTION")) return C_CONNECTIONSym;
  		if (EqualStr("CASTING")) return C_CASTINGSym;
  		if (EqualStr("CONCATENATE")) return C_CONCATENATESym;
  		if (EqualStr("CHARACTER")) return C_CHARACTERSym;
  		if (EqualStr("CONSTANTS")) return C_CONSTANTSSym;
  		if (EqualStr("COMMON")) return C_COMMONSym;
  		if (EqualStr("CENTERED")) return C_CENTEREDSym;
  		if (EqualStr("CURRENCY")) return C_CURRENCYSym;
  		if (EqualStr("CHECKBOX")) return C_CHECKBOXSym;
  		if (EqualStr("CONTINUE")) return C_CONTINUESym;
  		if (EqualStr("CASE")) return C_CASESym;
  		if (EqualStr("COMPARING")) return C_COMPARINGSym;
  		if (EqualStr("CURRENT")) return C_CURRENTSym;
  		if (EqualStr("CHANGE")) return C_CHANGESym;
  		if (EqualStr("CURSOR")) return C_CURSORSym;
  		if (EqualStr("CODE")) return C_CODESym;
  		if (EqualStr("CONVERSION")) return C_CONVERSIONSym;
  		if (EqualStr("CP")) return C_CPSym;
  		if (EqualStr("CATCH")) return C_CATCHSym;
  		if (EqualStr("CLEANUP")) return C_CLEANUPSym;
  		if (EqualStr("CALLING")) return C_CALLINGSym;
  		if (EqualStr("CLASS")) return C_CLASSSym;
  		if (EqualStr("CRITICAL")) return C_CRITICALSym;
  		if (EqualStr("CONDITION")) return C_CONDITIONSym;
  		if (EqualStr("COMPONENT")) return C_COMPONENTSym;
  		if (EqualStr("CALL")) return C_CALLSym;
  		if (EqualStr("CLEAR")) return C_CLEARSym;
  		if (EqualStr("CLOSE")) return C_CLOSESym;
  		if (EqualStr("COLLECT")) return C_COLLECTSym;
  		if (EqualStr("COMMIT")) return C_COMMITSym;
  		if (EqualStr("COMPUTE")) return C_COMPUTESym;
  		if (EqualStr("CONDENSE")) return C_CONDENSESym;
  		if (EqualStr("CONTROLS")) return C_CONTROLSSym;
  		if (EqualStr("CONVERT")) return C_CONVERTSym;
  		if (EqualStr("CONTEXT")) return C_CONTEXTSym;
  		if (EqualStr("COMPRESSION")) return C_COMPRESSIONSym;
  		if (EqualStr("COUNT")) return C_COUNTSym;
  		if (EqualStr("COLOR")) return C_COLORSym;
  		if (EqualStr("COL_BACKGROUND")) return C_COLUnderscoreBACKGROUNDSym;
  		if (EqualStr("COL_HEADING")) return C_COLUnderscoreHEADINGSym;
  		if (EqualStr("COL_NORMAL")) return C_COLUnderscoreNORMALSym;
  		if (EqualStr("COL_TOTAL")) return C_COLUnderscoreTOTALSym;
  		if (EqualStr("COL_KEY")) return C_COLUnderscoreKEYSym;
  		if (EqualStr("COL_POSITIVE")) return C_COLUnderscorePOSITIVESym;
  		if (EqualStr("COL_NEGATIVE")) return C_COLUnderscoreNEGATIVESym;
  		if (EqualStr("COL_GROUP")) return C_COLUnderscoreGROUPSym;
  		if (EqualStr("COUNTRY")) return C_COUNTRYSym;
  		if (EqualStr("CONTROL")) return C_CONTROLSym;
  		if (EqualStr("COLUMN")) return C_COLUMNSym;
  		if (EqualStr("CLOCK")) return C_CLOCKSym;
  		if (EqualStr("CIRCULAR")) return C_CIRCULARSym;
  		if (EqualStr("CHANNELS")) return C_CHANNELSSym;
  		if (EqualStr("CO")) return C_COSym;
  		if (EqualStr("CN")) return C_CNSym;
  		if (EqualStr("CA")) return C_CASym;
  		if (EqualStr("CS")) return C_CSSym;
  		if (EqualStr("CHECK")) return C_CHECKSym;
  		if (EqualStr("CLASS-DATA")) return C_CLASSMinusDATASym;
  		if (EqualStr("CHANGING")) return C_CHANGINGSym;
  		if (EqualStr("CLASS-METHODS")) return C_CLASSMinusMETHODSSym;
  		if (EqualStr("CUSTOMER-FUNCTION")) return C_CUSTOMERMinusFUNCTIONSym;
  		if (EqualStr("CLASS-EVENTS")) return C_CLASSMinusEVENTSSym;
  		if (EqualStr("CLASS-POOL")) return C_CLASSMinusPOOLSym;
  		if (EqualStr("CHAR-TO-HEX")) return C_CHARMinusTOMinusHEXSym;
  		break;
  	case 'D':
  		if (EqualStr("DATA")) return C_DATASym;
  		if (EqualStr("DEFAULT")) return C_DEFAULTSym;
  		if (EqualStr("DECIMALS")) return C_DECIMALSSym;
  		if (EqualStr("DELETE")) return C_DELETESym;
  		if (EqualStr("DEFINING")) return C_DEFININGSym;
  		if (EqualStr("DATABASE")) return C_DATABASESym;
  		if (EqualStr("DISTINCT")) return C_DISTINCTSym;
  		if (EqualStr("DESCENDING")) return C_DESCENDINGSym;
  		if (EqualStr("DISPLAY")) return C_DISPLAYSym;
  		if (EqualStr("DDMMYY")) return C_DDMMYYSym;
  		if (EqualStr("DUMMY")) return C_DUMMYSym;
  		if (EqualStr("DATASET")) return C_DATASETSym;
  		if (EqualStr("DUPLICATES")) return C_DUPLICATESSym;
  		if (EqualStr("DO")) return C_DOSym;
  		if (EqualStr("DYNPRO")) return C_DYNPROSym;
  		if (EqualStr("DESTINATION")) return C_DESTINATIONSym;
  		if (EqualStr("DEFINITION")) return C_DEFINITIONSym;
  		if (EqualStr("DEFERRED")) return C_DEFERREDSym;
  		if (EqualStr("DANGEROUS")) return C_DANGEROUSSym;
  		if (EqualStr("DURATION")) return C_DURATIONSym;
  		if (EqualStr("DIALOG")) return C_DIALOGSym;
  		if (EqualStr("DAYLIGHT")) return C_DAYLIGHTSym;
  		if (EqualStr("DEMAND")) return C_DEMANDSym;
  		if (EqualStr("DESCRIBE")) return C_DESCRIBESym;
  		if (EqualStr("DISTANCE")) return C_DISTANCESym;
  		if (EqualStr("DETAIL")) return C_DETAILSym;
  		if (EqualStr("DIVIDE")) return C_DIVIDESym;
  		if (EqualStr("DIRECTORY")) return C_DIRECTORYSym;
  		if (EqualStr("DUPLICATE")) return C_DUPLICATESym;
  		if (EqualStr("DELETING")) return C_DELETINGSym;
  		if (EqualStr("DURING")) return C_DURINGSym;
  		if (EqualStr("DIV")) return C_DIVSym;
  		if (EqualStr("DD/MM/YY")) return C_DDSlashMMSlashYYSym;
  		if (EqualStr("DD/MM/YYYY")) return C_DDSlashMMSlashYYYYSym;
  		if (EqualStr("DIVIDE-CORRESPONDING")) return C_DIVIDEMinusCORRESPONDINGSym;
  		if (EqualStr("DISPLAY-MODE")) return C_DISPLAYMinusMODESym;
  		break;
  	case 'E':
  		if (EqualStr("END")) return C_ENDSym;
  		if (EqualStr("EXCEPTIONS")) return C_EXCEPTIONSSym;
  		if (EqualStr("EOF")) return C_EOFSym;
  		if (EqualStr("ENDFUNCTION")) return C_ENDFUNCTIONSym;
  		if (EqualStr("ENDSELECT")) return C_ENDSELECTSym;
  		if (EqualStr("ENTRIES")) return C_ENTRIESSym;
  		if (EqualStr("EXTENDED")) return C_EXTENDEDSym;
  		if (EqualStr("ENDWITH")) return C_ENDWITHSym;
  		if (EqualStr("EXACT")) return C_EXACTSym;
  		if (EqualStr("EXPANDING")) return C_EXPANDINGSym;
  		if (EqualStr("ENDING")) return C_ENDINGSym;
  		if (EqualStr("EVENT")) return C_EVENTSym;
  		if (EqualStr("EXCEPTION")) return C_EXCEPTIONSym;
  		if (EqualStr("ENDLOOP")) return C_ENDLOOPSym;
  		if (EqualStr("EMPTY")) return C_EMPTYSym;
  		if (EqualStr("EXPONENT")) return C_EXPONENTSym;
  		if (EqualStr("ENVIRONMENT")) return C_ENVIRONMENTSym;
  		if (EqualStr("ENDCASE")) return C_ENDCASESym;
  		if (EqualStr("ENDDO")) return C_ENDDOSym;
  		if (EqualStr("EVENTS")) return C_EVENTSSym;
  		if (EqualStr("ENDON")) return C_ENDONSym;
  		if (EqualStr("ENCODING")) return C_ENCODINGSym;
  		if (EqualStr("ENDIAN")) return C_ENDIANSym;
  		if (EqualStr("ERRORS")) return C_ERRORSSym;
  		if (EqualStr("ENDPROVIDE")) return C_ENDPROVIDESym;
  		if (EqualStr("EQ")) return C_EQSym;
  		if (EqualStr("ENDTRY")) return C_ENDTRYSym;
  		if (EqualStr("ENUM")) return C_ENUMSym;
  		if (EqualStr("ENDWHILE")) return C_ENDWHILESym;
  		if (EqualStr("ELSEIF")) return C_ELSEIFSym;
  		if (EqualStr("ELSE")) return C_ELSESym;
  		if (EqualStr("ENDIF")) return C_ENDIFSym;
  		if (EqualStr("ENABLED")) return C_ENABLEDSym;
  		if (EqualStr("ENDCLASS")) return C_ENDCLASSSym;
  		if (EqualStr("ENDMETHOD")) return C_ENDMETHODSym;
  		if (EqualStr("ENDAT")) return C_ENDATSym;
  		if (EqualStr("EXIT")) return C_EXITSym;
  		if (EqualStr("EXPORT")) return C_EXPORTSym;
  		if (EqualStr("EXTRACT")) return C_EXTRACTSym;
  		if (EqualStr("EXCLUDING")) return C_EXCLUDINGSym;
  		if (EqualStr("ENTRY")) return C_ENTRYSym;
  		if (EqualStr("ENABLING")) return C_ENABLINGSym;
  		if (EqualStr("ENDINTERFACE")) return C_ENDINTERFACESym;
  		if (EqualStr("ENDMODULE")) return C_ENDMODULESym;
  		if (EqualStr("EQUIV")) return C_EQUIVSym;
  		if (EqualStr("EDIT")) return C_EDITSym;
  		if (EqualStr("EXPORTING")) return C_EXPORTINGSym;
  		if (EqualStr("EXCEPTION-TABLE")) return C_EXCEPTIONMinusTABLESym;
  		if (EqualStr("END-LINES")) return C_ENDMinusLINESSym;
  		if (EqualStr("EDITOR-CALL")) return C_EDITORMinusCALLSym;
  		if (EqualStr("END-OF-PAGE")) return C_ENDMinusOFMinusPAGESym;
  		if (EqualStr("END-OF-SELECTION")) return C_ENDMinusOFMinusSELECTIONSym;
  		if (EqualStr("END-TEST-INJECTION")) return C_ENDMinusTESTMinusINJECTIONSym;
  		if (EqualStr("END-TEST-SEAM")) return C_ENDMinusTESTMinusSEAMSym;
  		break;
  	case 'F':
  		if (EqualStr("FUNCTIONALITY")) return C_FUNCTIONALITYSym;
  		if (EqualStr("FUNCTION")) return C_FUNCTIONSym;
  		if (EqualStr("FIELDS")) return C_FIELDSSym;
  		if (EqualStr("FROM")) return C_FROMSym;
  		if (EqualStr("FOR")) return C_FORSym;
  		if (EqualStr("FORMAT")) return C_FORMATSym;
  		if (EqualStr("FIELD")) return C_FIELDSym;
  		if (EqualStr("FILTER")) return C_FILTERSym;
  		if (EqualStr("FETCH")) return C_FETCHSym;
  		if (EqualStr("FREE")) return C_FREESym;
  		if (EqualStr("FINAL")) return C_FINALSym;
  		if (EqualStr("FRIENDS")) return C_FRIENDSSym;
  		if (EqualStr("FAIL")) return C_FAILSym;
  		if (EqualStr("FIRST")) return C_FIRSTSym;
  		if (EqualStr("FLUSH")) return C_FLUSHSym;
  		if (EqualStr("FIND")) return C_FINDSym;
  		if (EqualStr("FRAMES")) return C_FRAMESSym;
  		if (EqualStr("FILTERS")) return C_FILTERSSym;
  		if (EqualStr("FOUND")) return C_FOUNDSym;
  		if (EqualStr("FORWARD")) return C_FORWARDSym;
  		if (EqualStr("FILE")) return C_FILESym;
  		if (EqualStr("FIRST-LINE")) return C_FIRSTMinusLINESym;
  		if (EqualStr("FIELD-GROUPS")) return C_FIELDMinusGROUPSSym;
  		if (EqualStr("FIELD-SYMBOLS")) return C_FIELDMinusSYMBOLSSym;
  		if (EqualStr("FUNCTION-POOL")) return C_FUNCTIONMinusPOOLSym;
  		if (EqualStr("FILTER-TABLE")) return C_FILTERMinusTABLESym;
  		if (EqualStr("FIXED-POINT")) return C_FIXEDMinusPOINTSym;
  		break;
  	case 'G':
  		if (EqualStr("GROUP")) return C_GROUPSym;
  		if (EqualStr("GAPS")) return C_GAPSSym;
  		if (EqualStr("GE")) return C_GESym;
  		if (EqualStr("GT")) return C_GTSym;
  		if (EqualStr("GLOBAL")) return C_GLOBALSym;
  		if (EqualStr("GIVING")) return C_GIVINGSym;
  		if (EqualStr("GENERATE")) return C_GENERATESym;
  		if (EqualStr("GET")) return C_GETSym;
  		break;
  	case 'H':
  		if (EqualStr("HEADING")) return C_HEADINGSym;
  		if (EqualStr("HAVING")) return C_HAVINGSym;
  		if (EqualStr("HANDLE")) return C_HANDLESym;
  		if (EqualStr("HEADER")) return C_HEADERSym;
  		if (EqualStr("HOLD")) return C_HOLDSym;
  		if (EqualStr("HARMLESS")) return C_HARMLESSSym;
  		if (EqualStr("HOTSPOT")) return C_HOTSPOTSym;
  		if (EqualStr("HIDE")) return C_HIDESym;
  		if (EqualStr("HIGH")) return C_HIGHSym;
  		if (EqualStr("HANDLER")) return C_HANDLERSym;
  		if (EqualStr("HASHED")) return C_HASHEDSym;
  		if (EqualStr("HELP-ID")) return C_HELPMinusIDSym;
  		if (EqualStr("HEAD-LINES")) return C_HEADMinusLINESSym;
  		if (EqualStr("HELP-REQUEST")) return C_HELPMinusREQUESTSym;
  		break;
  	case 'I':
  		if (EqualStr("ID")) return C_IDSym;
  		if (EqualStr("INNER")) return C_INNERSym;
  		if (EqualStr("IN")) return C_INSym;
  		if (EqualStr("INDEX")) return C_INDEXSym;
  		if (EqualStr("IS")) return C_ISSym;
  		if (EqualStr("ICON")) return C_ICONSym;
  		if (EqualStr("INPUT")) return C_INPUTSym;
  		if (EqualStr("IGNORING")) return C_IGNORINGSym;
  		if (EqualStr("INCLUDING")) return C_INCLUDINGSym;
  		if (EqualStr("IF")) return C_IFSym;
  		if (EqualStr("INHERITING")) return C_INHERITINGSym;
  		if (EqualStr("IMPLEMENTATION")) return C_IMPLEMENTATIONSym;
  		if (EqualStr("IGNORE")) return C_IGNORESym;
  		if (EqualStr("INCREMENT")) return C_INCREMENTSym;
  		if (EqualStr("INTERNAL")) return C_INTERNALSym;
  		if (EqualStr("INTENSIFIED")) return C_INTENSIFIEDSym;
  		if (EqualStr("INVERSE")) return C_INVERSESym;
  		if (EqualStr("INCLUDE")) return C_INCLUDESym;
  		if (EqualStr("IMPORT")) return C_IMPORTSym;
  		if (EqualStr("INFOTYPES")) return C_INFOTYPESSym;
  		if (EqualStr("INITIALIZATION")) return C_INITIALIZATIONSym;
  		if (EqualStr("INSERT")) return C_INSERTSym;
  		if (EqualStr("INTERFACE")) return C_INTERFACESym;
  		if (EqualStr("INTERFACES")) return C_INTERFACESSym;
  		if (EqualStr("IMPLEMENTED")) return C_IMPLEMENTEDSym;
  		if (EqualStr("INTERVALS")) return C_INTERVALSSym;
  		if (EqualStr("INSTANCES")) return C_INSTANCESSym;
  		if (EqualStr("IMMEDIATELY")) return C_IMMEDIATELYSym;
  		if (EqualStr("INSTANCE")) return C_INSTANCESym;
  		if (EqualStr("INITIAL")) return C_INITIALSym;
  		if (EqualStr("IMPORTING")) return C_IMPORTINGSym;
  		if (EqualStr("INTO")) return C_INTOSym;
  		if (EqualStr("INTERFACE-POOL")) return C_INTERFACEMinusPOOLSym;
  		if (EqualStr("INDEX-LINE")) return C_INDEXMinusLINESym;
  		break;
  	case 'J':
  		if (EqualStr("JOIN")) return C_JOINSym;
  		if (EqualStr("JOB")) return C_JOBSym;
  		break;
  	case 'K':
  		if (EqualStr("KEY")) return C_KEYSym;
  		if (EqualStr("KIND")) return C_KINDSym;
  		if (EqualStr("KEEPING")) return C_KEEPINGSym;
  		if (EqualStr("KEYS")) return C_KEYSSym;
  		break;
  	case 'L':
  		if (EqualStr("LENGTH")) return C_LENGTHSym;
  		if (EqualStr("LEFT")) return C_LEFTSym;
  		if (EqualStr("LOCATOR")) return C_LOCATORSym;
  		if (EqualStr("LINE")) return C_LINESym;
  		if (EqualStr("LIKE")) return C_LIKESym;
  		if (EqualStr("LOOP")) return C_LOOPSym;
  		if (EqualStr("LOB")) return C_LOBSym;
  		if (EqualStr("LINEFEED")) return C_LINEFEEDSym;
  		if (EqualStr("LEGACY")) return C_LEGACYSym;
  		if (EqualStr("LITTLE")) return C_LITTLESym;
  		if (EqualStr("LANGUAGE")) return C_LANGUAGESym;
  		if (EqualStr("LT")) return C_LTSym;
  		if (EqualStr("LE")) return C_LESym;
  		if (EqualStr("LIST")) return C_LISTSym;
  		if (EqualStr("LEVEL")) return C_LEVELSym;
  		if (EqualStr("LONG")) return C_LONGSym;
  		if (EqualStr("LOAD")) return C_LOADSym;
  		if (EqualStr("LAST")) return C_LASTSym;
  		if (EqualStr("LOCALE")) return C_LOCALESym;
  		if (EqualStr("LEAVE")) return C_LEAVESym;
  		if (EqualStr("LOCAL")) return C_LOCALSym;
  		if (EqualStr("LISTBOX")) return C_LISTBOXSym;
  		if (EqualStr("LOWER")) return C_LOWERSym;
  		if (EqualStr("LOW")) return C_LOWSym;
  		if (EqualStr("LEADING")) return C_LEADINGSym;
  		if (EqualStr("LINES")) return C_LINESSym;
  		if (EqualStr("LINE-SIZE")) return C_LINEMinusSIZESym;
  		if (EqualStr("LINE-COUNT")) return C_LINEMinusCOUNTSym;
  		if (EqualStr("LEFT-JUSTIFIED")) return C_LEFTMinusJUSTIFIEDSym;
  		if (EqualStr("LIST-PROCESSING")) return C_LISTMinusPROCESSINGSym;
  		if (EqualStr("LOAD-OF-PROGRAM")) return C_LOADMinusOFMinusPROGRAMSym;
  		if (EqualStr("LOG-POINT")) return C_LOGMinusPOINTSym;
  		if (EqualStr("LINE-SELECTION")) return C_LINEMinusSELECTIONSym;
  		break;
  	case 'M':
  		if (EqualStr("MESSAGE")) return C_MESSAGESym;
  		if (EqualStr("MOVE")) return C_MOVESym;
  		if (EqualStr("MODE")) return C_MODESym;
  		if (EqualStr("MARK")) return C_MARKSym;
  		if (EqualStr("MEMBERS")) return C_MEMBERSSym;
  		if (EqualStr("MASK")) return C_MASKSym;
  		if (EqualStr("MMDDYY")) return C_MMDDYYSym;
  		if (EqualStr("MEMORY")) return C_MEMORYSym;
  		if (EqualStr("MODIFY")) return C_MODIFYSym;
  		if (EqualStr("MAXIMUM")) return C_MAXIMUMSym;
  		if (EqualStr("MESH")) return C_MESHSym;
  		if (EqualStr("MEDIUM")) return C_MEDIUMSym;
  		if (EqualStr("METHOD")) return C_METHODSym;
  		if (EqualStr("METHODS")) return C_METHODSSym;
  		if (EqualStr("MESSAGES")) return C_MESSAGESSym;
  		if (EqualStr("MATCH")) return C_MATCHSym;
  		if (EqualStr("MODIFIER")) return C_MODIFIERSym;
  		if (EqualStr("MINIMUM")) return C_MINIMUMSym;
  		if (EqualStr("MODULE")) return C_MODULESym;
  		if (EqualStr("MULTIPLY")) return C_MULTIPLYSym;
  		if (EqualStr("MODIF")) return C_MODIFSym;
  		if (EqualStr("MATCHCODE")) return C_MATCHCODESym;
  		if (EqualStr("MARGIN")) return C_MARGINSym;
  		if (EqualStr("MESSAGING")) return C_MESSAGINGSym;
  		if (EqualStr("MOD")) return C_MODSym;
  		if (EqualStr("MESSAGE-ID")) return C_MESSAGEMinusIDSym;
  		if (EqualStr("MOVE-CORRESPONDING")) return C_MOVEMinusCORRESPONDINGSym;
  		if (EqualStr("MM/DD/YY")) return C_MMSlashDDSlashYYSym;
  		if (EqualStr("MM/DD/YYYY")) return C_MMSlashDDSlashYYYYSym;
  		if (EqualStr("MAJOR-ID")) return C_MAJORMinusIDSym;
  		if (EqualStr("MINOR-ID")) return C_MINORMinusIDSym;
  		if (EqualStr("MULTIPLY-CORRESPONDING")) return C_MULTIPLYMinusCORRESPONDINGSym;
  		break;
  	case 'N':
  		if (EqualStr("NO")) return C_NOSym;
  		if (EqualStr("NESTED")) return C_NESTEDSym;
  		if (EqualStr("NUMBER")) return C_NUMBERSym;
  		if (EqualStr("NEXT")) return C_NEXTSym;
  		if (EqualStr("NATIVE")) return C_NATIVESym;
  		if (EqualStr("NE")) return C_NESym;
  		if (EqualStr("NP")) return C_NPSym;
  		if (EqualStr("NOT")) return C_NOTSym;
  		if (EqualStr("NEW")) return C_NEWSym;
  		if (EqualStr("NULL")) return C_NULLSym;
  		if (EqualStr("NODES")) return C_NODESSym;
  		if (EqualStr("NA")) return C_NASym;
  		if (EqualStr("NS")) return C_NSSym;
  		if (EqualStr("NODE")) return C_NODESym;
  		if (EqualStr("NON-UNIQUE")) return C_NONMinusUNIQUESym;
  		if (EqualStr("NO-GAP")) return C_NOMinusGAPSym;
  		if (EqualStr("NO-GROUPING")) return C_NOMinusGROUPINGSym;
  		if (EqualStr("NO-SIGN")) return C_NOMinusSIGNSym;
  		if (EqualStr("NO-ZERO")) return C_NOMinusZEROSym;
  		if (EqualStr("NON-UNICODE")) return C_NONMinusUNICODESym;
  		if (EqualStr("NO-GAPS")) return C_NOMinusGAPSSym;
  		if (EqualStr("NEW-LINE")) return C_NEWMinusLINESym;
  		if (EqualStr("NO-SCROLLING")) return C_NOMinusSCROLLINGSym;
  		if (EqualStr("NEW-PAGE")) return C_NEWMinusPAGESym;
  		if (EqualStr("NO-TITLE")) return C_NOMinusTITLESym;
  		if (EqualStr("NO-HEADING")) return C_NOMinusHEADINGSym;
  		if (EqualStr("NO-TOPOFPAGE")) return C_NOMinusTOPOFPAGESym;
  		if (EqualStr("NEW-SECTION")) return C_NEWMinusSECTIONSym;
  		if (EqualStr("NO-DISPLAY")) return C_NOMinusDISPLAYSym;
  		if (EqualStr("NO-EXTENSION")) return C_NOMinusEXTENSIONSym;
  		break;
  	case 'O':
  		if (EqualStr("OF")) return C_OFSym;
  		if (EqualStr("OUTER")) return C_OUTERSym;
  		if (EqualStr("ON")) return C_ONSym;
  		if (EqualStr("ORDER")) return C_ORDERSym;
  		if (EqualStr("OFFSET")) return C_OFFSETSym;
  		if (EqualStr("OCCURS")) return C_OCCURSSym;
  		if (EqualStr("OR")) return C_ORSym;
  		if (EqualStr("OTHERS")) return C_OTHERSSym;
  		if (EqualStr("OBJECT")) return C_OBJECTSym;
  		if (EqualStr("OPTIONAL")) return C_OPTIONALSym;
  		if (EqualStr("OPEN")) return C_OPENSym;
  		if (EqualStr("OUTPUT")) return C_OUTPUTSym;
  		if (EqualStr("OPTIONS")) return C_OPTIONSSym;
  		if (EqualStr("OBJECTS")) return C_OBJECTSSym;
  		if (EqualStr("OFF")) return C_OFFSym;
  		if (EqualStr("OCCURRENCE")) return C_OCCURRENCESym;
  		if (EqualStr("OCCURRENCES")) return C_OCCURRENCESSym;
  		if (EqualStr("OVERLAY")) return C_OVERLAYSym;
  		if (EqualStr("ONLY")) return C_ONLYSym;
  		if (EqualStr("OBLIGATORY")) return C_OBLIGATORYSym;
  		if (EqualStr("OPTION")) return C_OPTIONSym;
  		if (EqualStr("OTHER")) return C_OTHERSym;
  		if (EqualStr("OUTPUT-LENGTH")) return C_OUTPUTMinusLENGTHSym;
  		break;
  	case 'P':
  		if (EqualStr("PARAMETER")) return C_PARAMETERSym;
  		if (EqualStr("PARAMETERS")) return C_PARAMETERSSym;
  		if (EqualStr("PAGE")) return C_PAGESym;
  		if (EqualStr("PRIMARY")) return C_PRIMARYSym;
  		if (EqualStr("PACKAGE")) return C_PACKAGESym;
  		if (EqualStr("PERCENTAGE")) return C_PERCENTAGESym;
  		if (EqualStr("PRIMARY_KEY")) return C_PRIMARYUnderscoreKEYSym;
  		if (EqualStr("PART")) return C_PARTSym;
  		if (EqualStr("POSITION")) return C_POSITIONSym;
  		if (EqualStr("PROVIDE")) return C_PROVIDESym;
  		if (EqualStr("PROGRAM")) return C_PROGRAMSym;
  		if (EqualStr("PERFORMING")) return C_PERFORMINGSym;
  		if (EqualStr("PUBLIC")) return C_PUBLICSym;
  		if (EqualStr("PROTECTED")) return C_PROTECTEDSym;
  		if (EqualStr("PRIVATE")) return C_PRIVATESym;
  		if (EqualStr("PREFERRED")) return C_PREFERREDSym;
  		if (EqualStr("PROCEDURE")) return C_PROCEDURESym;
  		if (EqualStr("PAGES")) return C_PAGESSym;
  		if (EqualStr("POOL")) return C_POOLSym;
  		if (EqualStr("PROPERTY")) return C_PROPERTYSym;
  		if (EqualStr("PADDING")) return C_PADDINGSym;
  		if (EqualStr("PERSON")) return C_PERSONSym;
  		if (EqualStr("PARTIALLY")) return C_PARTIALLYSym;
  		if (EqualStr("PRINT")) return C_PRINTSym;
  		if (EqualStr("PACK")) return C_PACKSym;
  		if (EqualStr("PATTERN")) return C_PATTERNSym;
  		if (EqualStr("PERFORM")) return C_PERFORMSym;
  		if (EqualStr("PLACES")) return C_PLACESSym;
  		if (EqualStr("PUSH")) return C_PUSHSym;
  		if (EqualStr("PARAMETER-TABLE")) return C_PARAMETERMinusTABLESym;
  		if (EqualStr("PF-STATUS")) return C_PFMinusSTATUSSym;
  		if (EqualStr("PRINT-CONTROL")) return C_PRINTMinusCONTROLSym;
  		break;
  	case 'Q':
  		if (EqualStr("QUICKINFO")) return C_QUICKINFOSym;
  		if (EqualStr("QUEUE-ONLY")) return C_QUEUEMinusONLYSym;
  		break;
  	case 'R':
  		if (EqualStr("REPORT")) return C_REPORTSym;
  		if (EqualStr("REDUCED")) return C_REDUCEDSym;
  		if (EqualStr("RIGHT")) return C_RIGHTSym;
  		if (EqualStr("RESULT")) return C_RESULTSym;
  		if (EqualStr("READER")) return C_READERSym;
  		if (EqualStr("ROWS")) return C_ROWSSym;
  		if (EqualStr("RESPECTING")) return C_RESPECTINGSym;
  		if (EqualStr("RAISE")) return C_RAISESym;
  		if (EqualStr("RESUMABLE")) return C_RESUMABLESym;
  		if (EqualStr("RAISING")) return C_RAISINGSym;
  		if (EqualStr("ROUND")) return C_ROUNDSym;
  		if (EqualStr("REPLACEMENT")) return C_REPLACEMENTSym;
  		if (EqualStr("READ")) return C_READSym;
  		if (EqualStr("RETURN")) return C_RETURNSym;
  		if (EqualStr("RISK")) return C_RISKSym;
  		if (EqualStr("REDEFINITION")) return C_REDEFINITIONSym;
  		if (EqualStr("REGEX")) return C_REGEXSym;
  		if (EqualStr("RESULTS")) return C_RESULTSSym;
  		if (EqualStr("RESET")) return C_RESETSym;
  		if (EqualStr("RUN")) return C_RUNSym;
  		if (EqualStr("RENAMING")) return C_RENAMINGSym;
  		if (EqualStr("RADIOBUTTON")) return C_RADIOBUTTONSym;
  		if (EqualStr("ROLLBACK")) return C_ROLLBACKSym;
  		if (EqualStr("RANGES")) return C_RANGESSym;
  		if (EqualStr("RECEIVE")) return C_RECEIVESym;
  		if (EqualStr("REFRESH")) return C_REFRESHSym;
  		if (EqualStr("REJECT")) return C_REJECTSym;
  		if (EqualStr("REPLACE")) return C_REPLACESym;
  		if (EqualStr("RESERVE")) return C_RESERVESym;
  		if (EqualStr("RESUME")) return C_RESUMESym;
  		if (EqualStr("RETRY")) return C_RETRYSym;
  		if (EqualStr("RESOLUTION")) return C_RESOLUTIONSym;
  		if (EqualStr("REQUESTED")) return C_REQUESTEDSym;
  		if (EqualStr("REF")) return C_REFSym;
  		if (EqualStr("REFERENCE")) return C_REFERENCESym;
  		if (EqualStr("RANGE")) return C_RANGESym;
  		if (EqualStr("RETURNING")) return C_RETURNINGSym;
  		if (EqualStr("READ-ONLY")) return C_READMinusONLYSym;
  		if (EqualStr("RIGHT-JUSTIFIED")) return C_RIGHTMinusJUSTIFIEDSym;
  		if (EqualStr("RECEIVING")) return C_RECEIVINGSym;
  		break;
  	case 'S':
  		if (EqualStr("SUFFIX")) return C_SUFFIXSym;
  		if (EqualStr("SPECIFIED")) return C_SPECIFIEDSym;
  		if (EqualStr("SIZE")) return C_SIZESym;
  		if (EqualStr("SELECT")) return C_SELECTSym;
  		if (EqualStr("SINGLE")) return C_SINGLESym;
  		if (EqualStr("SEPARATED")) return C_SEPARATEDSym;
  		if (EqualStr("SEARCH")) return C_SEARCHSym;
  		if (EqualStr("STARTING")) return C_STARTINGSym;
  		if (EqualStr("SCREEN")) return C_SCREENSym;
  		if (EqualStr("STATICS")) return C_STATICSSym;
  		if (EqualStr("STYLE")) return C_STYLESym;
  		if (EqualStr("SYMBOL")) return C_SYMBOLSym;
  		if (EqualStr("SHARED")) return C_SHAREDSym;
  		if (EqualStr("SKIPPING")) return C_SKIPPINGSym;
  		if (EqualStr("SMART")) return C_SMARTSym;
  		if (EqualStr("SORT")) return C_SORTSym;
  		if (EqualStr("SUBMIT")) return C_SUBMITSym;
  		if (EqualStr("SELECTIONS")) return C_SELECTIONSSym;
  		if (EqualStr("SPOOL")) return C_SPOOLSym;
  		if (EqualStr("STRUCTURE")) return C_STRUCTURESym;
  		if (EqualStr("SET")) return C_SETSym;
  		if (EqualStr("SEPARATE")) return C_SEPARATESym;
  		if (EqualStr("SHORT")) return C_SHORTSym;
  		if (EqualStr("SECTION")) return C_SECTIONSym;
  		if (EqualStr("SUBKEY")) return C_SUBKEYSym;
  		if (EqualStr("SKIP")) return C_SKIPSym;
  		if (EqualStr("SOURCE")) return C_SOURCESym;
  		if (EqualStr("SORTABLE")) return C_SORTABLESym;
  		if (EqualStr("STAMP")) return C_STAMPSym;
  		if (EqualStr("SAVING")) return C_SAVINGSym;
  		if (EqualStr("SQL")) return C_SQLSym;
  		if (EqualStr("SUBSTRING")) return C_SUBSTRINGSym;
  		if (EqualStr("SUBMATCHES")) return C_SUBMATCHESSym;
  		if (EqualStr("SUBROUTINE")) return C_SUBROUTINESym;
  		if (EqualStr("SCROLLING")) return C_SCROLLINGSym;
  		if (EqualStr("SCROLL")) return C_SCROLLSym;
  		if (EqualStr("SELECTION")) return C_SELECTIONSym;
  		if (EqualStr("SHIFT")) return C_SHIFTSym;
  		if (EqualStr("STOP")) return C_STOPSym;
  		if (EqualStr("SUBTRACT")) return C_SUBTRACTSym;
  		if (EqualStr("SUM")) return C_SUMSym;
  		if (EqualStr("SUMMARY")) return C_SUMMARYSym;
  		if (EqualStr("SUMMING")) return C_SUMMINGSym;
  		if (EqualStr("SUPPLY")) return C_SUPPLYSym;
  		if (EqualStr("SUPPRESS")) return C_SUPPRESSSym;
  		if (EqualStr("SWITCHSTATES")) return C_SWITCHSTATESSym;
  		if (EqualStr("SECONDS")) return C_SECONDSSym;
  		if (EqualStr("SPLIT")) return C_SPLITSym;
  		if (EqualStr("SUPPLIED")) return C_SUPPLIEDSym;
  		if (EqualStr("SORTED")) return C_SORTEDSym;
  		if (EqualStr("STANDARD")) return C_STANDARDSym;
  		if (EqualStr("STABLE")) return C_STABLESym;
  		if (EqualStr("SELECTION-SCREEN")) return C_SELECTIONMinusSCREENSym;
  		if (EqualStr("SELECTION-SET")) return C_SELECTIONMinusSETSym;
  		if (EqualStr("SELECTION-SETS")) return C_SELECTIONMinusSETSSym;
  		if (EqualStr("SELECTION-TABLE")) return C_SELECTIONMinusTABLESym;
  		if (EqualStr("SAP-SPOOL")) return C_SAPMinusSPOOLSym;
  		if (EqualStr("STEP-LOOP")) return C_STEPMinusLOOPSym;
  		if (EqualStr("SHORTDUMP-ID")) return C_SHORTDUMPMinusIDSym;
  		if (EqualStr("SELECT-OPTIONS")) return C_SELECTMinusOPTIONSSym;
  		if (EqualStr("SCROLL-BOUNDARY")) return C_SCROLLMinusBOUNDARYSym;
  		if (EqualStr("SUBTRACT-CORRESPONDING")) return C_SUBTRACTMinusCORRESPONDINGSym;
  		if (EqualStr("SYNTAX-CHECK")) return C_SYNTAXMinusCHECKSym;
  		break;
  	case 'T':
  		if (EqualStr("TARGET")) return C_TARGETSym;
  		if (EqualStr("TO")) return C_TOSym;
  		if (EqualStr("TABLES")) return C_TABLESSym;
  		if (EqualStr("TEXT")) return C_TEXTSym;
  		if (EqualStr("TIME")) return C_TIMESym;
  		if (EqualStr("TIMES")) return C_TIMESSym;
  		if (EqualStr("TEXTPOOL")) return C_TEXTPOOLSym;
  		if (EqualStr("TRY")) return C_TRYSym;
  		if (EqualStr("TYPES")) return C_TYPESSym;
  		if (EqualStr("TASK")) return C_TASKSym;
  		if (EqualStr("TESTING")) return C_TESTINGSym;
  		if (EqualStr("THEN")) return C_THENSym;
  		if (EqualStr("TRANSACTION")) return C_TRANSACTIONSym;
  		if (EqualStr("TRANSFORMATION")) return C_TRANSFORMATIONSym;
  		if (EqualStr("TABLEVIEW")) return C_TABLEVIEWSym;
  		if (EqualStr("TABSTRIP")) return C_TABSTRIPSym;
  		if (EqualStr("TITLE")) return C_TITLESym;
  		if (EqualStr("TRUNCATION")) return C_TRUNCATIONSym;
  		if (EqualStr("TAB")) return C_TABSym;
  		if (EqualStr("TITLEBAR")) return C_TITLEBARSym;
  		if (EqualStr("TRAILING")) return C_TRAILINGSym;
  		if (EqualStr("TRANSFER")) return C_TRANSFERSym;
  		if (EqualStr("TRANSLATE")) return C_TRANSLATESym;
  		if (EqualStr("TRUNCATE")) return C_TRUNCATESym;
  		if (EqualStr("TASKS")) return C_TASKSSym;
  		if (EqualStr("TRANSPORTING")) return C_TRANSPORTINGSym;
  		if (EqualStr("TYPE")) return C_TYPESym;
  		if (EqualStr("TYPE-POOL")) return C_TYPEMinusPOOLSym;
  		if (EqualStr("TABLE")) return C_TABLESym;
  		if (EqualStr("TOP-LINES")) return C_TOPMinusLINESSym;
  		if (EqualStr("TITLE-LINES")) return C_TITLEMinusLINESSym;
  		if (EqualStr("TEST-INJECTION")) return C_TESTMinusINJECTIONSym;
  		if (EqualStr("TEST-SEAM")) return C_TESTMinusSEAMSym;
  		if (EqualStr("TOP-OF-PAGE")) return C_TOPMinusOFMinusPAGESym;
  		if (EqualStr("TYPE-POOLS")) return C_TYPEMinusPOOLSSym;
  		break;
  	case 'U':
  		if (EqualStr("USING")) return C_USINGSym;
  		if (EqualStr("UPDATE")) return C_UPDATESym;
  		if (EqualStr("UNION")) return C_UNIONSym;
  		if (EqualStr("UP")) return C_UPSym;
  		if (EqualStr("UNIQUE")) return C_UNIQUESym;
  		if (EqualStr("UNDER")) return C_UNDERSym;
  		if (EqualStr("UNIT")) return C_UNITSym;
  		if (EqualStr("USER")) return C_USERSym;
  		if (EqualStr("UNIX")) return C_UNIXSym;
  		if (EqualStr("UNWIND")) return C_UNWINDSym;
  		if (EqualStr("UNTIL")) return C_UNTILSym;
  		if (EqualStr("UNICODE")) return C_UNICODESym;
  		if (EqualStr("UPPER")) return C_UPPERSym;
  		if (EqualStr("ULINE")) return C_ULINESym;
  		if (EqualStr("UNASSIGN")) return C_UNASSIGNSym;
  		if (EqualStr("UNPACK")) return C_UNPACKSym;
  		if (EqualStr("USER-COMMAND")) return C_USERMinusCOMMANDSym;
  		break;
  	case 'V':
  		if (EqualStr("VALUE")) return C_VALUESym;
  		if (EqualStr("VERSION")) return C_VERSIONSym;
  		if (EqualStr("VALID")) return C_VALIDSym;
  		if (EqualStr("VARYING")) return C_VARYINGSym;
  		if (EqualStr("VIA")) return C_VIASym;
  		if (EqualStr("VARY")) return C_VARYSym;
  		if (EqualStr("VALUES")) return C_VALUESSym;
  		if (EqualStr("VISIBLE")) return C_VISIBLESym;
  		if (EqualStr("VALUE-REQUEST")) return C_VALUEMinusREQUESTSym;
  		break;
  	case 'W':
  		if (EqualStr("WHERE")) return C_WHERESym;
  		if (EqualStr("WITHOUT")) return C_WITHOUTSym;
  		if (EqualStr("WRITE")) return C_WRITESym;
  		if (EqualStr("WHEN")) return C_WHENSym;
  		if (EqualStr("WINDOWS")) return C_WINDOWSSym;
  		if (EqualStr("WIDTH")) return C_WIDTHSym;
  		if (EqualStr("WHILE")) return C_WHILESym;
  		if (EqualStr("WORK")) return C_WORKSym;
  		if (EqualStr("WAIT")) return C_WAITSym;
  		if (EqualStr("WINDOW")) return C_WINDOWSym;
  		if (EqualStr("WITH")) return C_WITHSym;
  		if (EqualStr("WITH-TITLE")) return C_WITHMinusTITLESym;
  		if (EqualStr("WITH-HEADING")) return C_WITHMinusHEADINGSym;
  		break;
  	case 'X':
  		if (EqualStr("XML")) return C_XMLSym;
  		break;
  	case 'Y':
  		if (EqualStr("YYMMDD")) return C_YYMMDDSym;
  		break;
  	case 'Z':
  		if (EqualStr("ZONE")) return C_ZONESym;
  		break;
  	case 'a':
  		if (EqualStr("aggregate")) return C_aggregateSym;
  		break;
  	case 'c':
  		if (EqualStr("communication_failure")) return C_communicationUnderscorefaiSym;
  		break;
  	case 'e':
  		if (EqualStr("error_message")) return C_errorUnderscoremessageSym;
  		break;
  	case 'f':
  		if (EqualStr("for")) return C_forSym;
  		break;
  	case 'r':
  		if (EqualStr("resource_failure")) return C_resourceUnderscorefailureSym;
  		if (EqualStr("return")) return C_returnSym;
  		break;
  	case 's':
  		if (EqualStr("system_failure")) return C_systemUnderscorefailureSym;
  		break;
  	case '|':
  		if (EqualStr("||")) return C_BarBarSym;
  		break;
  
  }
  return id;
}

int cScanner::Comment()
{ int Level, StartLine, OldCol;
  long OldLineStart;

  Level = 1; StartLine = CurrLine;
  OldLineStart = LineStart; OldCol = CurrCol;
  if (Scan_Ch == '/') { /* 1 */
  	Scan_NextCh();
  	if (Scan_Ch == '*') { /* 2 */
  		Scan_NextCh();
  		while (1) {
  			if (Scan_Ch== '*') { /* 5 */
  				Scan_NextCh();
  				if (Scan_Ch == '/') { /* 6 */
  					Level--; Scan_NextCh(); Scan_ComEols = Scan_CurrLine - StartLine;
  					if(Level == 0) return 1;
  				} /* 6 */ 
  			} else /* 5 */
  			if (Scan_Ch == EOF_CHAR) return 0;
  			else Scan_NextCh();
  		} /* while */
  	} else { /* 2 */
  		if (Scan_Ch == LF_CHAR) { Scan_CurrLine--; Scan_LineStart = OldLineStart; }
  		Scan_BuffPos -= 2; Scan_CurrCol = OldCol - 1; Scan_NextCh();
  	} /* 2 */
  } /* 1*/
  if (Scan_Ch == '"') { /* 1 */
  	Scan_NextCh();
  		while (1) {
  			if (Scan_Ch== 10) { /* 5 */
  				Level--; Scan_NextCh(); Scan_ComEols = Scan_CurrLine - StartLine;
  				if(Level == 0) return 1;
  			} else /* 5 */
  			if (Scan_Ch == EOF_CHAR) return 0;
  			else Scan_NextCh();
  		} /* while */
  } /* 1*/
  
  return 0;
}

int cScanner::UpdateState()
{
    state = STATE0[Ch.to_byte()];
    while(1) {
      Scan_NextCh(); NextSym.Len++;
      switch (state) {
       /* State 0; valid STATE0 Table
      case 0:
      	if (Scan_Ch >= '1' && Scan_Ch <= '9') state = 1; else
      	if (Scan_Ch == '0') state = 32; else
      	if (Scan_Ch == 39) state = 13; else
      	if (Scan_Ch == '`') state = 14; else
      	if (Scan_Ch == '"') state = 17; else
      	if (Scan_Ch == '|') state = 21; else
      	if (Scan_Ch == ':') state = 23; else
      	if (Scan_Ch == ' ') state = 24; else
      	if (Scan_Ch >= 'A' && Scan_Ch <= 'Z' ||
          Scan_Ch == '_' ||
          Scan_Ch >= 'a' && Scan_Ch <= 'z') state = 26; else
      	if (Scan_Ch == '!') state = 89; else
      	if (Scan_Ch == '#') state = 29; else
      	if (Scan_Ch == '(') state = 36; else
      	if (Scan_Ch == ')') state = 37; else
      	if (Scan_Ch == '=') state = 38; else
      	if (Scan_Ch == '.') state = 40; else
      	if (Scan_Ch == '*') state = 41; else
      	if (Scan_Ch == ',') state = 42; else
      	if (Scan_Ch == '~') state = 43; else
      	if (Scan_Ch == '@') state = 45; else
      	if (Scan_Ch == '+') state = 50; else
      	if (Scan_Ch == '?') state = 51; else
      	if (Scan_Ch == '[') state = 54; else
      	if (Scan_Ch == ']') state = 55; else
      	if (Scan_Ch == '/') state = 90; else
      	if (Scan_Ch == ';') state = 58; else
      	if (Scan_Ch == '-') state = 59; else
      	if (Scan_Ch == '&') state = 61; else
      	if (Scan_Ch == '^') state = 63; else
      	if (Scan_Ch == '<') state = 91; else
      	if (Scan_Ch == '>') state = 67; else
      	if (Scan_Ch == '%') state = 74; else
      	return No_Sym;
      	break;
       --------- End State0 --------- */
      case 1:
      	if (Scan_Ch == 'U') state = 2; else
      	if (Scan_Ch == 'u') state = 3; else
      	if (Scan_Ch == 'L') state = 4; else
      	if (Scan_Ch == 'l') state = 5; else
      	if (Scan_Ch >= '0' && Scan_Ch <= '9') /*same state*/; else
      	return C_numberSym;
      	break;
      case 2:
      	return C_numberSym;
      case 3:
      	return C_numberSym;
      case 4:
      	return C_numberSym;
      case 5:
      	return C_numberSym;
      case 7:
      	if (Scan_Ch >= '0' && Scan_Ch <= '9' ||
      	    Scan_Ch >= 'A' && Scan_Ch <= 'F' ||
      	    Scan_Ch >= 'a' && Scan_Ch <= 'f') state = 8; else
      	return No_Sym;
      	break;
      case 8:
      	if (Scan_Ch == 'U') state = 9; else
      	if (Scan_Ch == 'u') state = 10; else
      	if (Scan_Ch == 'L') state = 11; else
      	if (Scan_Ch == 'l') state = 12; else
      	if (Scan_Ch >= '0' && Scan_Ch <= '9' ||
      	    Scan_Ch >= 'A' && Scan_Ch <= 'F' ||
      	    Scan_Ch >= 'a' && Scan_Ch <= 'f') /*same state*/; else
      	return C_hexnumberSym;
      	break;
      case 9:
      	return C_hexnumberSym;
      case 10:
      	return C_hexnumberSym;
      case 11:
      	return C_hexnumberSym;
      case 12:
      	return C_hexnumberSym;
      case 13:
      	if (Scan_Ch == 39) state = 15; else
      	if (Scan_Ch >= ' ' && Scan_Ch <= '&' ||
      	    Scan_Ch >= '(' && Scan_Ch <= 255) /*same state*/; else
      	return No_Sym;
      	break;
      case 14:
      	if (Scan_Ch == '`') state = 16; else
      	if (Scan_Ch >= ' ' && Scan_Ch <= '_' ||
      	    Scan_Ch >= 'a' && Scan_Ch <= 255) /*same state*/; else
      	return No_Sym;
      	break;
      case 15:
      	return C_stringD1Sym;
      case 16:
      	return C_stringD1Sym;
      case 17:
      	if (Scan_Ch >= ' ' && Scan_Ch <= '!' ||
      	    Scan_Ch >= '#' && Scan_Ch <= '[' ||
      	    Scan_Ch >= ']' && Scan_Ch <= 255) state = 19; else
      	if (Scan_Ch == 92) state = 33; else
      	return No_Sym;
      	break;
      case 19:
      	if (Scan_Ch == '"') state = 20; else
      	return No_Sym;
      	break;
      case 20:
      	return C_charSym;
      case 21:
      	if (Scan_Ch == '|') state = 22; else
      	if (Scan_Ch >= ' ' && Scan_Ch <= '{' ||
      	    Scan_Ch >= '}' && Scan_Ch <= 255) /*same state*/; else
      	return C_BarSym;
      	break;
      case 22:
      	return CheckLiteral(C_regexD1Sym);
      case 23:
      	return C_ColonSym;
      case 24:
      	return C_spaceD1Sym;
      case 26:
      	if (Scan_Ch >= '0' && Scan_Ch <= '9' ||
      	    Scan_Ch == '<' ||
      	    Scan_Ch == '>' ||
      	    Scan_Ch >= 'A' && Scan_Ch <= 'Z' ||
      	    Scan_Ch == '_' ||
      	    Scan_Ch >= 'a' && Scan_Ch <= 'z') /*same state*/; else
      	if (Scan_Ch == '/' ||
      	    Scan_Ch == '~') state = 27; else
      	if (Scan_Ch == '-') state = 34; else
      	return CheckLiteral(C_identifierSym);
      	break;
      case 27:
      	if (Scan_Ch == '*' ||
      	    Scan_Ch >= '0' && Scan_Ch <= '9' ||
      	    Scan_Ch == '<' ||
      	    Scan_Ch == '>' ||
      	    Scan_Ch >= 'A' && Scan_Ch <= 'Z' ||
      	    Scan_Ch == '_' ||
      	    Scan_Ch >= 'a' && Scan_Ch <= 'z') state = 26; else
      	return No_Sym;
      	break;
      case 29:
      	if (Scan_Ch == '#') state = 30; else
      	return C_HashSym;
      	break;
      case 30:
      	if (Scan_Ch >= 'A' && Scan_Ch <= 'Z' ||
      	    Scan_Ch == '_' ||
      	    Scan_Ch >= 'a' && Scan_Ch <= 'z') state = 31; else
      	return No_Sym;
      	break;
      case 31:
      	if (Scan_Ch >= '0' && Scan_Ch <= '9' ||
      	    Scan_Ch >= 'A' && Scan_Ch <= 'Z' ||
      	    Scan_Ch == '_' ||
      	    Scan_Ch >= 'a' && Scan_Ch <= 'z') /*same state*/; else
      	return C_PreProcessorSym;
      	break;
      case 32:
      	if (Scan_Ch == 'U') state = 2; else
      	if (Scan_Ch == 'u') state = 3; else
      	if (Scan_Ch == 'L') state = 4; else
      	if (Scan_Ch == 'l') state = 5; else
      	if (Scan_Ch >= '0' && Scan_Ch <= '9') state = 1; else
      	if (Scan_Ch == 'X' ||
      	    Scan_Ch == 'x') state = 7; else
      	return C_numberSym;
      	break;
      case 33:
      	if (Scan_Ch >= ' ' && Scan_Ch <= '!' ||
      	    Scan_Ch >= '#' && Scan_Ch <= 255) state = 19; else
      	if (Scan_Ch == '"') state = 20; else
      	return No_Sym;
      	break;
      case 34:
      	if (Scan_Ch == '*' ||
      	    Scan_Ch >= '0' && Scan_Ch <= '9' ||
      	    Scan_Ch == '<' ||
      	    Scan_Ch >= 'A' && Scan_Ch <= 'Z' ||
      	    Scan_Ch == '_' ||
      	    Scan_Ch >= 'a' && Scan_Ch <= 'z') state = 26; else
      	if (Scan_Ch == '>') state = 35; else
      	return No_Sym;
      	break;
      case 35:
      	if (Scan_Ch == '*' ||
      	    Scan_Ch >= '0' && Scan_Ch <= '9' ||
      	    Scan_Ch == '<' ||
      	    Scan_Ch == '>' ||
      	    Scan_Ch >= 'A' && Scan_Ch <= 'Z' ||
      	    Scan_Ch == '_' ||
      	    Scan_Ch >= 'a' && Scan_Ch <= 'z') state = 26; else
      	if (Scan_Ch == '/' ||
      	    Scan_Ch == '~') state = 27; else
      	if (Scan_Ch == '-') state = 34; else
      	return CheckLiteral(C_identifierSym);
      	break;
      case 36:
      	return C_LparenSym;
      case 37:
      	return C_RparenSym;
      case 38:
      	if (Scan_Ch == '>') state = 39; else
      	return C_EqualSym;
      	break;
      case 39:
      	return C_EqualGreaterSym;
      case 40:
      	return C_PointSym;
      case 41:
      	if (Scan_Ch == '*') state = 57; else
      	if (Scan_Ch == '=') state = 75; else
      	return C_StarSym;
      	break;
      case 42:
      	return C_CommaSym;
      case 43:
      	if (Scan_Ch == '*') state = 44; else
      	return C_TildeSym;
      	break;
      case 44:
      	return C_TildeStarSym;
      case 45:
      	if (Scan_Ch == 'D') state = 46; else
      	return C_AtSym;
      	break;
      case 46:
      	if (Scan_Ch == 'A') state = 47; else
      	return No_Sym;
      	break;
      case 47:
      	if (Scan_Ch == 'T') state = 48; else
      	return No_Sym;
      	break;
      case 48:
      	if (Scan_Ch == 'A') state = 49; else
      	return No_Sym;
      	break;
      case 49:
      	return C_AtDATASym;
      case 50:
      	if (Scan_Ch == '=') state = 79; else
      	return C_PlusSym;
      	break;
      case 51:
      	if (Scan_Ch == 'T') state = 52; else
      	if (Scan_Ch == '=') state = 87; else
      	return C_QuerySym;
      	break;
      case 52:
      	if (Scan_Ch == 'O') state = 53; else
      	return No_Sym;
      	break;
      case 53:
      	return C_QueryTOSym;
      case 54:
      	return C_LbrackSym;
      case 55:
      	return C_RbrackSym;
      case 57:
      	return C_StarStarSym;
      case 58:
      	return C_SemicolonSym;
      case 59:
      	if (Scan_Ch == '>') state = 60; else
      	if (Scan_Ch == '=') state = 80; else
      	return C_MinusSym;
      	break;
      case 60:
      	return C_MinusGreaterSym;
      case 61:
      	if (Scan_Ch == '&') state = 62; else
      	if (Scan_Ch == '=') state = 81; else
      	return C_AndSym;
      	break;
      case 62:
      	return C_AndAndSym;
      case 63:
      	if (Scan_Ch == '=') state = 82; else
      	return C_UparrowSym;
      	break;
      case 65:
      	return C_LessGreaterSym;
      case 67:
      	if (Scan_Ch == '=') state = 70; else
      	if (Scan_Ch == '>') state = 73; else
      	return C_GreaterSym;
      	break;
      case 69:
      	return C_LessEqualSym;
      case 70:
      	return C_GreaterEqualSym;
      case 73:
      	if (Scan_Ch == '=') state = 86; else
      	return C_GreaterGreaterSym;
      	break;
      case 74:
      	if (Scan_Ch == '=') state = 78; else
      	return C_PercentSym;
      	break;
      case 75:
      	return C_StarEqualSym;
      case 77:
      	return C_SlashEqualSym;
      case 78:
      	return C_PercentEqualSym;
      case 79:
      	return C_PlusEqualSym;
      case 80:
      	return C_MinusEqualSym;
      case 81:
      	return C_AndEqualSym;
      case 82:
      	return C_UparrowEqualSym;
      case 85:
      	return C_LessLessEqualSym;
      case 86:
      	return C_GreaterGreaterEqualSym;
      case 87:
      	return C_QueryEqualSym;
      case 89:
      	if (Scan_Ch >= 'A' && Scan_Ch <= 'Z' ||
      	    Scan_Ch == '_' ||
      	    Scan_Ch >= 'a' && Scan_Ch <= 'z') state = 26; else
      	return C_BangSym;
      	break;
      case 90:
      	if (Scan_Ch >= 'A' && Scan_Ch <= 'Z' ||
      	    Scan_Ch == '_' ||
      	    Scan_Ch >= 'a' && Scan_Ch <= 'z') state = 26; else
      	if (Scan_Ch == '=') state = 77; else
      	return C_SlashSym;
      	break;
      case 91:
      	if (Scan_Ch >= 'A' && Scan_Ch <= 'Z' ||
      	    Scan_Ch == '_' ||
      	    Scan_Ch >= 'a' && Scan_Ch <= 'z') state = 26; else
      	if (Scan_Ch == '>') state = 65; else
      	if (Scan_Ch == '=') state = 69; else
      	if (Scan_Ch == '<') state = 92; else
      	return C_LessSym;
      	break;
      case 92:
      	if (Scan_Ch == '=') state = 85; else
      	return C_LessLessSym;
      	break;
      
      default: return No_Sym; /* Scan_NextCh already done */
      }
    }
}

int cScanner::Get1()
{ int state, ctx;

  start:
    while (Scan_Ch >= 9 && Scan_Ch <= 10 ||
    	       Scan_Ch == 13 ||
    	       Scan_Ch == ' ') Scan_NextCh();
    if ((Scan_Ch == '"' ||
    	                                Scan_Ch == '/') && Comment()) goto start;

    CurrSym = NextSym;
    NextSym.Init(0, CurrLine, CurrCol - 1, BuffPos, 0);
    NextSym.Len  = 0; ctx = 0;

    if (Ch == EOF_CHAR) return EOF_Sym;
    state = STATE0[Ch];
    while(1) {
      Scan_NextCh(); NextSym.Len++;
      switch (state) {
       /* State 0; valid STATE0 Table
      case 0:
      	if (Scan_Ch >= '1' && Scan_Ch <= '9') state = 1; else
      	if (Scan_Ch == '0') state = 32; else
      	if (Scan_Ch == 39) state = 13; else
      	if (Scan_Ch == '`') state = 14; else
      	if (Scan_Ch == '"') state = 17; else
      	if (Scan_Ch == '|') state = 21; else
      	if (Scan_Ch == ':') state = 23; else
      	if (Scan_Ch == ' ') state = 24; else
      	if (Scan_Ch >= 'A' && Scan_Ch <= 'Z' ||
      	    Scan_Ch == '_' ||
      	    Scan_Ch >= 'a' && Scan_Ch <= 'z') state = 26; else
      	if (Scan_Ch == '!') state = 89; else
      	if (Scan_Ch == '#') state = 29; else
      	if (Scan_Ch == '(') state = 36; else
      	if (Scan_Ch == ')') state = 37; else
      	if (Scan_Ch == '=') state = 38; else
      	if (Scan_Ch == '.') state = 40; else
      	if (Scan_Ch == '*') state = 41; else
      	if (Scan_Ch == ',') state = 42; else
      	if (Scan_Ch == '~') state = 43; else
      	if (Scan_Ch == '@') state = 45; else
      	if (Scan_Ch == '+') state = 50; else
      	if (Scan_Ch == '?') state = 51; else
      	if (Scan_Ch == '[') state = 54; else
      	if (Scan_Ch == ']') state = 55; else
      	if (Scan_Ch == '/') state = 90; else
      	if (Scan_Ch == ';') state = 58; else
      	if (Scan_Ch == '-') state = 59; else
      	if (Scan_Ch == '&') state = 61; else
      	if (Scan_Ch == '^') state = 63; else
      	if (Scan_Ch == '<') state = 91; else
      	if (Scan_Ch == '>') state = 67; else
      	if (Scan_Ch == '%') state = 74; else
      	return No_Sym;
      	break;
       --------- End State0 --------- */
      case 1:
      	if (Scan_Ch == 'U') state = 2; else
      	if (Scan_Ch == 'u') state = 3; else
      	if (Scan_Ch == 'L') state = 4; else
      	if (Scan_Ch == 'l') state = 5; else
      	if (Scan_Ch >= '0' && Scan_Ch <= '9') /*same state*/; else
      	return C_numberSym;
      	break;
      case 2:
      	return C_numberSym;
      case 3:
      	return C_numberSym;
      case 4:
      	return C_numberSym;
      case 5:
      	return C_numberSym;
      case 7:
      	if (Scan_Ch >= '0' && Scan_Ch <= '9' ||
      	    Scan_Ch >= 'A' && Scan_Ch <= 'F' ||
      	    Scan_Ch >= 'a' && Scan_Ch <= 'f') state = 8; else
      	return No_Sym;
      	break;
      case 8:
      	if (Scan_Ch == 'U') state = 9; else
      	if (Scan_Ch == 'u') state = 10; else
      	if (Scan_Ch == 'L') state = 11; else
      	if (Scan_Ch == 'l') state = 12; else
      	if (Scan_Ch >= '0' && Scan_Ch <= '9' ||
      	    Scan_Ch >= 'A' && Scan_Ch <= 'F' ||
      	    Scan_Ch >= 'a' && Scan_Ch <= 'f') /*same state*/; else
      	return C_hexnumberSym;
      	break;
      case 9:
      	return C_hexnumberSym;
      case 10:
      	return C_hexnumberSym;
      case 11:
      	return C_hexnumberSym;
      case 12:
      	return C_hexnumberSym;
      case 13:
      	if (Scan_Ch == 39) state = 15; else
      	if (Scan_Ch >= ' ' && Scan_Ch <= '&' ||
      	    Scan_Ch >= '(' && Scan_Ch <= 255) /*same state*/; else
      	return No_Sym;
      	break;
      case 14:
      	if (Scan_Ch == '`') state = 16; else
      	if (Scan_Ch >= ' ' && Scan_Ch <= '_' ||
      	    Scan_Ch >= 'a' && Scan_Ch <= 255) /*same state*/; else
      	return No_Sym;
      	break;
      case 15:
      	return C_stringD1Sym;
      case 16:
      	return C_stringD1Sym;
      case 17:
      	if (Scan_Ch >= ' ' && Scan_Ch <= '!' ||
      	    Scan_Ch >= '#' && Scan_Ch <= '[' ||
      	    Scan_Ch >= ']' && Scan_Ch <= 255) state = 19; else
      	if (Scan_Ch == 92) state = 33; else
      	return No_Sym;
      	break;
      case 19:
      	if (Scan_Ch == '"') state = 20; else
      	return No_Sym;
      	break;
      case 20:
      	return C_charSym;
      case 21:
      	if (Scan_Ch == '|') state = 22; else
      	if (Scan_Ch >= ' ' && Scan_Ch <= '{' ||
      	    Scan_Ch >= '}' && Scan_Ch <= 255) /*same state*/; else
      	return C_BarSym;
      	break;
      case 22:
      	return CheckLiteral(C_regexD1Sym);
      case 23:
      	return C_ColonSym;
      case 24:
      	return C_spaceD1Sym;
      case 26:
      	if (Scan_Ch >= '0' && Scan_Ch <= '9' ||
      	    Scan_Ch == '<' ||
      	    Scan_Ch == '>' ||
      	    Scan_Ch >= 'A' && Scan_Ch <= 'Z' ||
      	    Scan_Ch == '_' ||
      	    Scan_Ch >= 'a' && Scan_Ch <= 'z') /*same state*/; else
      	if (Scan_Ch == '/' ||
      	    Scan_Ch == '~') state = 27; else
      	if (Scan_Ch == '-') state = 34; else
      	return CheckLiteral(C_identifierSym);
      	break;
      case 27:
      	if (Scan_Ch == '*' ||
      	    Scan_Ch >= '0' && Scan_Ch <= '9' ||
      	    Scan_Ch == '<' ||
      	    Scan_Ch == '>' ||
      	    Scan_Ch >= 'A' && Scan_Ch <= 'Z' ||
      	    Scan_Ch == '_' ||
      	    Scan_Ch >= 'a' && Scan_Ch <= 'z') state = 26; else
      	return No_Sym;
      	break;
      case 29:
      	if (Scan_Ch == '#') state = 30; else
      	return C_HashSym;
      	break;
      case 30:
      	if (Scan_Ch >= 'A' && Scan_Ch <= 'Z' ||
      	    Scan_Ch == '_' ||
      	    Scan_Ch >= 'a' && Scan_Ch <= 'z') state = 31; else
      	return No_Sym;
      	break;
      case 31:
      	if (Scan_Ch >= '0' && Scan_Ch <= '9' ||
      	    Scan_Ch >= 'A' && Scan_Ch <= 'Z' ||
      	    Scan_Ch == '_' ||
      	    Scan_Ch >= 'a' && Scan_Ch <= 'z') /*same state*/; else
      	return C_PreProcessorSym;
      	break;
      case 32:
      	if (Scan_Ch == 'U') state = 2; else
      	if (Scan_Ch == 'u') state = 3; else
      	if (Scan_Ch == 'L') state = 4; else
      	if (Scan_Ch == 'l') state = 5; else
      	if (Scan_Ch >= '0' && Scan_Ch <= '9') state = 1; else
      	if (Scan_Ch == 'X' ||
      	    Scan_Ch == 'x') state = 7; else
      	return C_numberSym;
      	break;
      case 33:
      	if (Scan_Ch >= ' ' && Scan_Ch <= '!' ||
      	    Scan_Ch >= '#' && Scan_Ch <= 255) state = 19; else
      	if (Scan_Ch == '"') state = 20; else
      	return No_Sym;
      	break;
      case 34:
      	if (Scan_Ch == '*' ||
      	    Scan_Ch >= '0' && Scan_Ch <= '9' ||
      	    Scan_Ch == '<' ||
      	    Scan_Ch >= 'A' && Scan_Ch <= 'Z' ||
      	    Scan_Ch == '_' ||
      	    Scan_Ch >= 'a' && Scan_Ch <= 'z') state = 26; else
      	if (Scan_Ch == '>') state = 35; else
      	return No_Sym;
      	break;
      case 35:
      	if (Scan_Ch == '*' ||
      	    Scan_Ch >= '0' && Scan_Ch <= '9' ||
      	    Scan_Ch == '<' ||
      	    Scan_Ch == '>' ||
      	    Scan_Ch >= 'A' && Scan_Ch <= 'Z' ||
      	    Scan_Ch == '_' ||
      	    Scan_Ch >= 'a' && Scan_Ch <= 'z') state = 26; else
      	if (Scan_Ch == '/' ||
      	    Scan_Ch == '~') state = 27; else
      	if (Scan_Ch == '-') state = 34; else
      	return CheckLiteral(C_identifierSym);
      	break;
      case 36:
      	return C_LparenSym;
      case 37:
      	return C_RparenSym;
      case 38:
      	if (Scan_Ch == '>') state = 39; else
      	return C_EqualSym;
      	break;
      case 39:
      	return C_EqualGreaterSym;
      case 40:
      	return C_PointSym;
      case 41:
      	if (Scan_Ch == '*') state = 57; else
      	if (Scan_Ch == '=') state = 75; else
      	return C_StarSym;
      	break;
      case 42:
      	return C_CommaSym;
      case 43:
      	if (Scan_Ch == '*') state = 44; else
      	return C_TildeSym;
      	break;
      case 44:
      	return C_TildeStarSym;
      case 45:
      	if (Scan_Ch == 'D') state = 46; else
      	return C_AtSym;
      	break;
      case 46:
      	if (Scan_Ch == 'A') state = 47; else
      	return No_Sym;
      	break;
      case 47:
      	if (Scan_Ch == 'T') state = 48; else
      	return No_Sym;
      	break;
      case 48:
      	if (Scan_Ch == 'A') state = 49; else
      	return No_Sym;
      	break;
      case 49:
      	return C_AtDATASym;
      case 50:
      	if (Scan_Ch == '=') state = 79; else
      	return C_PlusSym;
      	break;
      case 51:
      	if (Scan_Ch == 'T') state = 52; else
      	if (Scan_Ch == '=') state = 87; else
      	return C_QuerySym;
      	break;
      case 52:
      	if (Scan_Ch == 'O') state = 53; else
      	return No_Sym;
      	break;
      case 53:
      	return C_QueryTOSym;
      case 54:
      	return C_LbrackSym;
      case 55:
      	return C_RbrackSym;
      case 57:
      	return C_StarStarSym;
      case 58:
      	return C_SemicolonSym;
      case 59:
      	if (Scan_Ch == '>') state = 60; else
      	if (Scan_Ch == '=') state = 80; else
      	return C_MinusSym;
      	break;
      case 60:
      	return C_MinusGreaterSym;
      case 61:
      	if (Scan_Ch == '&') state = 62; else
      	if (Scan_Ch == '=') state = 81; else
      	return C_AndSym;
      	break;
      case 62:
      	return C_AndAndSym;
      case 63:
      	if (Scan_Ch == '=') state = 82; else
      	return C_UparrowSym;
      	break;
      case 65:
      	return C_LessGreaterSym;
      case 67:
      	if (Scan_Ch == '=') state = 70; else
      	if (Scan_Ch == '>') state = 73; else
      	return C_GreaterSym;
      	break;
      case 69:
      	return C_LessEqualSym;
      case 70:
      	return C_GreaterEqualSym;
      case 73:
      	if (Scan_Ch == '=') state = 86; else
      	return C_GreaterGreaterSym;
      	break;
      case 74:
      	if (Scan_Ch == '=') state = 78; else
      	return C_PercentSym;
      	break;
      case 75:
      	return C_StarEqualSym;
      case 77:
      	return C_SlashEqualSym;
      case 78:
      	return C_PercentEqualSym;
      case 79:
      	return C_PlusEqualSym;
      case 80:
      	return C_MinusEqualSym;
      case 81:
      	return C_AndEqualSym;
      case 82:
      	return C_UparrowEqualSym;
      case 85:
      	return C_LessLessEqualSym;
      case 86:
      	return C_GreaterGreaterEqualSym;
      case 87:
      	return C_QueryEqualSym;
      case 89:
      	if (Scan_Ch >= 'A' && Scan_Ch <= 'Z' ||
      	    Scan_Ch == '_' ||
      	    Scan_Ch >= 'a' && Scan_Ch <= 'z') state = 26; else
      	return C_BangSym;
      	break;
      case 90:
      	if (Scan_Ch >= 'A' && Scan_Ch <= 'Z' ||
      	    Scan_Ch == '_' ||
      	    Scan_Ch >= 'a' && Scan_Ch <= 'z') state = 26; else
      	if (Scan_Ch == '=') state = 77; else
      	return C_SlashSym;
      	break;
      case 91:
      	if (Scan_Ch >= 'A' && Scan_Ch <= 'Z' ||
      	    Scan_Ch == '_' ||
      	    Scan_Ch >= 'a' && Scan_Ch <= 'z') state = 26; else
      	if (Scan_Ch == '>') state = 65; else
      	if (Scan_Ch == '=') state = 69; else
      	if (Scan_Ch == '<') state = 92; else
      	return C_LessSym;
      	break;
      case 92:
      	if (Scan_Ch == '=') state = 85; else
      	return C_LessLessSym;
      	break;
      
      default: return No_Sym; /* Scan_NextCh already done */
      }
    }
}

