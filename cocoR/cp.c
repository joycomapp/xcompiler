//****************************************************************
//   CPLUS2\PARSER_C.FRM
//   Coco/R C++ Support Frames.
//   Author: Frankie Arzu <farzu@uvg.edu.gt>
//
//   Jun 12, 1996  Version 1.06
//      Many fixes and suggestions thanks to
//      Pat Terry <p.terry@.ru.ac.za>
//   Oct 11, 1997  Version 1.07
//      Eliminated redundant ";" in some places
//****************************************************************

/*************** NOTICE ****************
	This file is generated by cocoR       
***************************************/

//#include "cc.h"
#include "cp.hpp"

__embedded__ RUBY

__embedend__



static void C(void)
{
_in_();
	while (Sym >= C_identifierSym && Sym <= C_stringSym ||
	       Sym >= C_regexD1Sym && Sym <= C_LparenSym ||
	       Sym >= C_nullSym && Sym <= C_LbrackSym ||
	       Sym == C_LbraceSym ||
	       Sym == C_newSym ||
	       Sym >= C_PlusPlusSym && Sym <= C_BangSym ||
	       Sym >= C_varSym && Sym <= C_ifSym ||
	       Sym >= C_doSym && Sym <= C_switchSym ||
	       Sym >= C_throwSym && Sym <= C_trySym ||
	       Sym >= C_functionSym && Sym <= C_importSym) {
		SourceElements();
	}
	Expect(EOF_Sym);
_out_();
}

static void SourceElements(void)
{
_in_();
	SourceElement();
	while (Sym >= C_identifierSym && Sym <= C_stringSym ||
	       Sym >= C_regexD1Sym && Sym <= C_LparenSym ||
	       Sym >= C_nullSym && Sym <= C_LbrackSym ||
	       Sym == C_LbraceSym ||
	       Sym == C_newSym ||
	       Sym >= C_PlusPlusSym && Sym <= C_BangSym ||
	       Sym >= C_varSym && Sym <= C_ifSym ||
	       Sym >= C_doSym && Sym <= C_switchSym ||
	       Sym >= C_throwSym && Sym <= C_trySym ||
	       Sym >= C_functionSym && Sym <= C_importSym) {
		SourceElement();
	}
_out_();
}

static void Boolean(void)
{
_in_();
	if (Sym == C_trueSym) {
		Get();
	} else if (Sym == C_falseSym) {
		Get();
	} else GenError(87);
_out_();
}

static void PrimaryExpression(void)
{
_in_();
	switch (Sym) {
		case C_thisSym:  
			Get();
			break;
		case C_LbraceSym:  
			ObjectLiteral();
			break;
		case C_LparenSym:  
			Get();
			Expression();
			Expect(C_RparenSym);
			break;
		case C_identifierSym:  
			Get();
			break;
		case C_LbrackSym:  
			ArrayLiteral();
			break;
		case C_numberSym: 
		case C_hexnumberSym: 
		case C_stringSym: 
		case C_regexD1Sym: 
		case C_trueSym: 
		case C_falseSym: 
		case C_nullSym:  
			Literal();
			break;
		default :GenError(88); break;
	}
_out_();
}

static void ObjectLiteral(void)
{
_in_();
	Expect(C_LbraceSym);
	if (Sym >= C_identifierSym && Sym <= C_numberSym ||
	    Sym == C_stringSym) {
		PropertyNameAndValueList();
	}
	Expect(C_RbraceSym);
_out_();
}

static void Expression(void)
{
_in_();
	AssignmentExpression();
	while (Sym == C_CommaSym) {
		Get();
		AssignmentExpression();
	}
_out_();
}

static void ArrayLiteral(void)
{
_in_();
	Expect(C_LbrackSym);
	if (Sym >= C_RbrackSym && Sym <= C_CommaSym) {
		if (Sym == C_CommaSym) {
			Elision();
		}
		Expect(C_RbrackSym);
	} else if (Sym >= C_identifierSym && Sym <= C_stringSym ||
	           Sym >= C_regexD1Sym && Sym <= C_LparenSym ||
	           Sym >= C_nullSym && Sym <= C_LbrackSym ||
	           Sym == C_LbraceSym ||
	           Sym == C_newSym ||
	           Sym >= C_PlusPlusSym && Sym <= C_BangSym ||
	           Sym == C_functionSym) {
		ElementList();
		Elision();
		Expect(C_RbrackSym);
	} else if (1) {
		if (Sym >= C_identifierSym && Sym <= C_stringSym ||
		    Sym >= C_regexD1Sym && Sym <= C_LparenSym ||
		    Sym >= C_nullSym && Sym <= C_LbrackSym ||
		    Sym >= C_CommaSym && Sym <= C_LbraceSym ||
		    Sym == C_newSym ||
		    Sym >= C_PlusPlusSym && Sym <= C_BangSym ||
		    Sym == C_functionSym) {
			ElementList();
		}
		Expect(C_RbrackSym);
	} else GenError(89);
_out_();
}

static void Literal(void)
{
_in_();
	switch (Sym) {
		case C_numberSym:  
			Get();
			break;
		case C_hexnumberSym:  
			Get();
			break;
		case C_stringSym:  
			Get();
			break;
		case C_trueSym: 
		case C_falseSym:  
			Boolean();
			break;
		case C_nullSym:  
			Get();
			break;
		case C_regexD1Sym:  
			Get();
			break;
		default :GenError(90); break;
	}
_out_();
}

static void Elision(void)
{
_in_();
	Expect(C_CommaSym);
	while (Sym == C_CommaSym) {
		Get();
	}
_out_();
}

static void ElementList(void)
{
_in_();
	if (Sym == C_CommaSym) {
		Elision();
	}
	AssignmentExpression();
	while (Sym == C_CommaSym) {
		Elision();
		AssignmentExpression();
	}
_out_();
}

static void AssignmentExpression(void)
{
_in_();
	if (Sym >= C_identifierSym && Sym <= C_stringSym ||
	    Sym >= C_regexD1Sym && Sym <= C_LparenSym ||
	    Sym >= C_nullSym && Sym <= C_LbrackSym ||
	    Sym == C_LbraceSym ||
	    Sym == C_newSym ||
	    Sym == C_functionSym) {
		LeftHandSideExpression();
		AssignmentOperator();
		AssignmentExpression();
	} else if (Sym >= C_PlusPlusSym && Sym <= C_BangSym) {
		ConditionalExpression();
	} else GenError(91);
_out_();
}

static void PropertyNameAndValueList(void)
{
_in_();
	PropertyNameAndValue();
	while (Sym == C_CommaSym) {
		if (Sym == C_CommaSym) {
			Get();
			PropertyNameAndValue();
		} else if (1) {
			Get();
		} else GenError(92);
	}
_out_();
}

static void PropertyNameAndValue(void)
{
_in_();
	PropertyName();
	Expect(C_ColonSym);
	AssignmentExpression();
_out_();
}

static void PropertyName(void)
{
_in_();
	if (Sym == C_identifierSym) {
		Get();
	} else if (Sym == C_stringSym) {
		Get();
	} else if (Sym == C_numberSym) {
		Get();
	} else GenError(93);
_out_();
}

static void MemberExpression(void)
{
_in_();
	if (Sym >= C_identifierSym && Sym <= C_stringSym ||
	    Sym >= C_regexD1Sym && Sym <= C_LparenSym ||
	    Sym >= C_nullSym && Sym <= C_LbrackSym ||
	    Sym == C_LbraceSym ||
	    Sym == C_functionSym) {
		if (Sym == C_functionSym) {
			FunctionExpression();
		} else if (Sym >= C_identifierSym && Sym <= C_stringSym ||
		           Sym >= C_regexD1Sym && Sym <= C_LparenSym ||
		           Sym >= C_nullSym && Sym <= C_LbrackSym ||
		           Sym == C_LbraceSym) {
			PrimaryExpression();
		} else GenError(94);
		while (Sym == C_LbrackSym ||
		       Sym == C_PointSym) {
			MemberExpressionPart();
		}
	} else if (Sym == C_newSym) {
		AllocationExpression();
	} else GenError(95);
_out_();
}

static void FunctionExpression(void)
{
_in_();
	Expect(C_functionSym);
	if (Sym == C_identifierSym) {
		Get();
	}
	Expect(C_LparenSym);
	if (Sym == C_identifierSym) {
		FormalParameterList();
	}
	Expect(C_RparenSym);
	FunctionBody();
_out_();
}

static void MemberExpressionPart(void)
{
_in_();
	if (Sym == C_LbrackSym) {
		Get();
		Expression();
		Expect(C_RbrackSym);
	} else if (Sym == C_PointSym) {
		Get();
		Expect(C_identifierSym);
	} else GenError(96);
_out_();
}

static void AllocationExpression(void)
{
_in_();
	Expect(C_newSym);
	MemberExpression();
	while (Sym == C_LparenSym) {
		Arguments();
		while (Sym == C_LbrackSym ||
		       Sym == C_PointSym) {
			MemberExpressionPart();
		}
	}
_out_();
}

static void MemberExpressionForIn(void)
{
_in_();
	if (Sym == C_functionSym) {
		FunctionExpression();
	} else if (Sym >= C_identifierSym && Sym <= C_stringSym ||
	           Sym >= C_regexD1Sym && Sym <= C_LparenSym ||
	           Sym >= C_nullSym && Sym <= C_LbrackSym ||
	           Sym == C_LbraceSym) {
		PrimaryExpression();
	} else GenError(97);
	while (Sym == C_LbrackSym ||
	       Sym == C_PointSym) {
		MemberExpressionPart();
	}
_out_();
}

static void Arguments(void)
{
_in_();
	Expect(C_LparenSym);
	if (Sym >= C_identifierSym && Sym <= C_stringSym ||
	    Sym >= C_regexD1Sym && Sym <= C_LparenSym ||
	    Sym >= C_nullSym && Sym <= C_LbrackSym ||
	    Sym == C_LbraceSym ||
	    Sym == C_newSym ||
	    Sym >= C_PlusPlusSym && Sym <= C_BangSym ||
	    Sym == C_functionSym) {
		ArgumentList();
	}
	Expect(C_RparenSym);
_out_();
}

static void CallExpression(void)
{
_in_();
	MemberExpression();
	Arguments();
	while (Sym == C_LparenSym ||
	       Sym == C_LbrackSym ||
	       Sym == C_PointSym) {
		CallExpressionPart();
	}
_out_();
}

static void CallExpressionPart(void)
{
_in_();
	if (Sym == C_LparenSym) {
		Arguments();
	} else if (Sym == C_LbrackSym) {
		Get();
		Expression();
		Expect(C_RbrackSym);
	} else if (Sym == C_PointSym) {
		Get();
		Expect(C_identifierSym);
	} else GenError(98);
_out_();
}

static void CallExpressionForIn(void)
{
_in_();
	MemberExpressionForIn();
	Arguments();
	while (Sym == C_LparenSym ||
	       Sym == C_LbrackSym ||
	       Sym == C_PointSym) {
		CallExpressionPart();
	}
_out_();
}

static void ArgumentList(void)
{
_in_();
	AssignmentExpression();
	while (Sym == C_CommaSym) {
		Get();
		AssignmentExpression();
	}
_out_();
}

static void LeftHandSideExpression(void)
{
_in_();
	if (Sym >= C_identifierSym && Sym <= C_stringSym ||
	    Sym >= C_regexD1Sym && Sym <= C_LparenSym ||
	    Sym >= C_nullSym && Sym <= C_LbrackSym ||
	    Sym == C_LbraceSym ||
	    Sym == C_newSym ||
	    Sym == C_functionSym) {
		CallExpression();
	} else if (1) {
		MemberExpression();
	} else GenError(99);
_out_();
}

static void LeftHandSideExpressionForIn(void)
{
_in_();
	if (Sym >= C_identifierSym && Sym <= C_stringSym ||
	    Sym >= C_regexD1Sym && Sym <= C_LparenSym ||
	    Sym >= C_nullSym && Sym <= C_LbrackSym ||
	    Sym == C_LbraceSym ||
	    Sym == C_functionSym) {
		CallExpressionForIn();
	} else if (1) {
		MemberExpressionForIn();
	} else GenError(100);
_out_();
}

static void PostfixExpression(void)
{
_in_();
	LeftHandSideExpression();
	if (Sym >= C_PlusPlusSym && Sym <= C_MinusMinusSym) {
		PostfixOperator();
	}
_out_();
}

static void PostfixOperator(void)
{
_in_();
	if (Sym == C_PlusPlusSym) {
		Get();
	} else if (Sym == C_MinusMinusSym) {
		Get();
	} else GenError(101);
_out_();
}

static void UnaryExpression(void)
{
_in_();
	if (Sym >= C_identifierSym && Sym <= C_stringSym ||
	    Sym >= C_regexD1Sym && Sym <= C_LparenSym ||
	    Sym >= C_nullSym && Sym <= C_LbrackSym ||
	    Sym == C_LbraceSym ||
	    Sym == C_newSym ||
	    Sym == C_functionSym) {
		PostfixExpression();
	} else if (Sym >= C_PlusPlusSym && Sym <= C_BangSym) {
		UnaryOperator();
		UnaryExpression();
		while (Sym >= C_PlusPlusSym && Sym <= C_BangSym) {
			UnaryOperator();
			UnaryExpression();
		}
	} else GenError(102);
_out_();
}

static void UnaryOperator(void)
{
_in_();
	switch (Sym) {
		case C_deleteSym:  
			Get();
			break;
		case C_voidSym:  
			Get();
			break;
		case C_typeofSym:  
			Get();
			break;
		case C_PlusPlusSym:  
			Get();
			break;
		case C_MinusMinusSym:  
			Get();
			break;
		case C_PlusSym:  
			Get();
			break;
		case C_MinusSym:  
			Get();
			break;
		case C_TildeSym:  
			Get();
			break;
		case C_BangSym:  
			Get();
			break;
		default :GenError(103); break;
	}
_out_();
}

static void MultiplicativeExpression(void)
{
_in_();
	UnaryExpression();
	while (Sym >= C_StarSym && Sym <= C_PercentSym) {
		MultiplicativeOperator();
		UnaryExpression();
	}
_out_();
}

static void MultiplicativeOperator(void)
{
_in_();
	if (Sym == C_StarSym) {
		Get();
	} else if (Sym == C_SlashSym) {
		Get();
	} else if (Sym == C_PercentSym) {
		Get();
	} else GenError(104);
_out_();
}

static void AdditiveExpression(void)
{
_in_();
	MultiplicativeExpression();
	while (Sym >= C_PlusSym && Sym <= C_MinusSym) {
		AdditiveOperator();
		MultiplicativeExpression();
	}
_out_();
}

static void AdditiveOperator(void)
{
_in_();
	if (Sym == C_PlusSym) {
		Get();
	} else if (Sym == C_MinusSym) {
		Get();
	} else GenError(105);
_out_();
}

static void ShiftExpression(void)
{
_in_();
	AdditiveExpression();
	while (Sym >= C_LessLessSym && Sym <= C_GreaterGreaterGreaterSym) {
		ShiftOperator();
		AdditiveExpression();
	}
_out_();
}

static void ShiftOperator(void)
{
_in_();
	if (Sym == C_LessLessSym) {
		Get();
	} else if (Sym == C_GreaterGreaterSym) {
		Get();
	} else if (Sym == C_GreaterGreaterGreaterSym) {
		Get();
	} else GenError(106);
_out_();
}

static void RelationalExpression(void)
{
_in_();
	ShiftExpression();
	while (Sym >= C_LessSym && Sym <= C_inSym) {
		RelationalOperator();
		ShiftExpression();
	}
_out_();
}

static void RelationalOperator(void)
{
_in_();
	switch (Sym) {
		case C_LessSym:  
			Get();
			break;
		case C_GreaterSym:  
			Get();
			break;
		case C_LessEqualSym:  
			Get();
			break;
		case C_GreaterEqualSym:  
			Get();
			break;
		case C_instanceofSym:  
			Get();
			break;
		case C_inSym:  
			Get();
			break;
		default :GenError(107); break;
	}
_out_();
}

static void RelationalExpressionNoIn(void)
{
_in_();
	ShiftExpression();
	while (Sym >= C_LessSym && Sym <= C_instanceofSym) {
		RelationalNoInOperator();
		ShiftExpression();
	}
_out_();
}

static void RelationalNoInOperator(void)
{
_in_();
	switch (Sym) {
		case C_LessSym:  
			Get();
			break;
		case C_GreaterSym:  
			Get();
			break;
		case C_LessEqualSym:  
			Get();
			break;
		case C_GreaterEqualSym:  
			Get();
			break;
		case C_instanceofSym:  
			Get();
			break;
		default :GenError(108); break;
	}
_out_();
}

static void EqualityExpression(void)
{
_in_();
	RelationalExpression();
	while (Sym >= C_EqualEqualSym && Sym <= C_BangEqualEqualSym) {
		EqualityOperator();
		RelationalExpression();
	}
_out_();
}

static void EqualityOperator(void)
{
_in_();
	switch (Sym) {
		case C_EqualEqualSym:  
			Get();
			break;
		case C_BangEqualSym:  
			Get();
			break;
		case C_EqualEqualEqualSym:  
			Get();
			break;
		case C_BangEqualEqualSym:  
			Get();
			break;
		default :GenError(109); break;
	}
_out_();
}

static void EqualityExpressionNoIn(void)
{
_in_();
	RelationalExpressionNoIn();
	while (Sym >= C_EqualEqualSym && Sym <= C_BangEqualEqualSym) {
		EqualityOperator();
		RelationalExpressionNoIn();
	}
_out_();
}

static void BitwiseANDExpression(void)
{
_in_();
	EqualityExpression();
	while (Sym == C_AndSym) {
		BitwiseANDOperator();
		EqualityExpression();
	}
_out_();
}

static void BitwiseANDOperator(void)
{
_in_();
	Expect(C_AndSym);
_out_();
}

static void BitwiseANDExpressionNoIn(void)
{
_in_();
	EqualityExpressionNoIn();
	while (Sym == C_AndSym) {
		BitwiseANDOperator();
		EqualityExpressionNoIn();
	}
_out_();
}

static void BitwiseXORExpression(void)
{
_in_();
	BitwiseANDExpression();
	while (Sym == C_UparrowSym) {
		BitwiseXOROperator();
		BitwiseANDExpression();
	}
_out_();
}

static void BitwiseXOROperator(void)
{
_in_();
	Expect(C_UparrowSym);
_out_();
}

static void BitwiseXORExpressionNoIn(void)
{
_in_();
	BitwiseANDExpressionNoIn();
	while (Sym == C_UparrowSym) {
		BitwiseXOROperator();
		BitwiseANDExpressionNoIn();
	}
_out_();
}

static void BitwiseORExpression(void)
{
_in_();
	BitwiseXORExpression();
	while (Sym == C_BarSym) {
		BitwiseOROperator();
		BitwiseXORExpression();
	}
_out_();
}

static void BitwiseOROperator(void)
{
_in_();
	Expect(C_BarSym);
_out_();
}

static void BitwiseORExpressionNoIn(void)
{
_in_();
	BitwiseXORExpressionNoIn();
	while (Sym == C_BarSym) {
		BitwiseOROperator();
		BitwiseXORExpressionNoIn();
	}
_out_();
}

static void LogicalANDExpression(void)
{
_in_();
	BitwiseORExpression();
	while (Sym == C_AndAndSym) {
		LogicalANDOperator();
		BitwiseORExpression();
	}
_out_();
}

static void LogicalANDOperator(void)
{
_in_();
	Expect(C_AndAndSym);
_out_();
}

static void LogicalANDExpressionNoIn(void)
{
_in_();
	BitwiseORExpressionNoIn();
	while (Sym == C_AndAndSym) {
		LogicalANDOperator();
		BitwiseORExpressionNoIn();
	}
_out_();
}

static void LogicalORExpression(void)
{
_in_();
	LogicalANDExpression();
	while (Sym == C_BarBarSym) {
		LogicalOROperator();
		LogicalANDExpression();
	}
_out_();
}

static void LogicalOROperator(void)
{
_in_();
	Expect(C_BarBarSym);
_out_();
}

static void LogicalORExpressionNoIn(void)
{
_in_();
	LogicalANDExpressionNoIn();
	while (Sym == C_BarBarSym) {
		LogicalOROperator();
		LogicalANDExpressionNoIn();
	}
_out_();
}

static void ConditionalExpression(void)
{
_in_();
	LogicalORExpression();
	if (Sym == C_QuerySym) {
		Get();
		AssignmentExpression();
		Expect(C_ColonSym);
		AssignmentExpression();
	}
_out_();
}

static void ConditionalExpressionNoIn(void)
{
_in_();
	LogicalORExpressionNoIn();
	if (Sym == C_QuerySym) {
		Get();
		AssignmentExpression();
		Expect(C_ColonSym);
		AssignmentExpressionNoIn();
	}
_out_();
}

static void AssignmentExpressionNoIn(void)
{
_in_();
	if (Sym >= C_identifierSym && Sym <= C_stringSym ||
	    Sym >= C_regexD1Sym && Sym <= C_LparenSym ||
	    Sym >= C_nullSym && Sym <= C_LbrackSym ||
	    Sym == C_LbraceSym ||
	    Sym == C_newSym ||
	    Sym == C_functionSym) {
		LeftHandSideExpression();
		AssignmentOperator();
		AssignmentExpressionNoIn();
	} else if (Sym >= C_PlusPlusSym && Sym <= C_BangSym) {
		ConditionalExpressionNoIn();
	} else GenError(110);
_out_();
}

static void AssignmentOperator(void)
{
_in_();
	switch (Sym) {
		case C_EqualSym:  
			Get();
			break;
		case C_StarEqualSym:  
			Get();
			break;
		case C_SlashEqualSym:  
			Get();
			break;
		case C_PercentEqualSym:  
			Get();
			break;
		case C_PlusEqualSym:  
			Get();
			break;
		case C_MinusEqualSym:  
			Get();
			break;
		case C_LessLessEqualSym:  
			Get();
			break;
		case C_GreaterGreaterEqualSym:  
			Get();
			break;
		case C_GreaterGreaterGreaterEqualSym:  
			Get();
			break;
		case C_AndEqualSym:  
			Get();
			break;
		case C_UparrowEqualSym:  
			Get();
			break;
		case C_BarEqualSym:  
			Get();
			break;
		default :GenError(111); break;
	}
_out_();
}

static void ExpressionNoIn(void)
{
_in_();
	AssignmentExpressionNoIn();
	while (Sym == C_CommaSym) {
		Get();
		AssignmentExpressionNoIn();
	}
_out_();
}

static void Statement(void)
{
_in_();
	switch (Sym) {
		case C_LbraceSym:  
			Block();
			break;
		case C_varSym:  
			JScriptVarStatement();
			break;
		default: 
			VariableStatement();
			break;
		case C_SemicolonSym:  
			EmptyStatement();
			break;
		case C_identifierSym:  
			LabelledStatement();
			break;
		case C_numberSym: 
		case C_hexnumberSym: 
		case C_stringSym: 
		case C_regexD1Sym: 
		case C_trueSym: 
		case C_falseSym: 
		case C_thisSym: 
		case C_LparenSym: 
		case C_nullSym: 
		case C_LbrackSym: 
		case C_newSym: 
		case C_PlusPlusSym: 
		case C_MinusMinusSym: 
		case C_deleteSym: 
		case C_voidSym: 
		case C_typeofSym: 
		case C_PlusSym: 
		case C_MinusSym: 
		case C_TildeSym: 
		case C_BangSym: 
		case C_functionSym:  
			ExpressionStatement();
			break;
		case C_ifSym:  
			IfStatement();
			break;
		case C_doSym: 
		case C_whileSym: 
		case C_forSym:  
			IterationStatement();
			break;
		case C_continueSym:  
			ContinueStatement();
			break;
		case C_breakSym:  
			BreakStatement();
			break;
		case C_importSym:  
			ImportStatement();
			break;
		case C_returnSym:  
			ReturnStatement();
			break;
		case C_withSym:  
			WithStatement();
			break;
		case C_switchSym:  
			SwitchStatement();
			break;
		case C_throwSym:  
			ThrowStatement();
			break;
		case C_trySym:  
			TryStatement();
			break;
		default :GenError(112); break;
	}
_out_();
}

static void Block(void)
{
_in_();
	Expect(C_LbraceSym);
	if (Sym >= C_identifierSym && Sym <= C_stringSym ||
	    Sym >= C_regexD1Sym && Sym <= C_LparenSym ||
	    Sym >= C_nullSym && Sym <= C_LbrackSym ||
	    Sym == C_LbraceSym ||
	    Sym == C_newSym ||
	    Sym >= C_PlusPlusSym && Sym <= C_BangSym ||
	    Sym >= C_varSym && Sym <= C_ifSym ||
	    Sym >= C_doSym && Sym <= C_switchSym ||
	    Sym >= C_throwSym && Sym <= C_trySym ||
	    Sym >= C_functionSym && Sym <= C_importSym) {
		StatementList();
	}
	Expect(C_RbraceSym);
_out_();
}

static void JScriptVarStatement(void)
{
_in_();
	Expect(C_varSym);
	JScriptVarDeclarationList();
	if (Sym == C_SemicolonSym) {
		Get();
	}
_out_();
}

static void VariableStatement(void)
{
_in_();
	Expect(C_varSym);
	VariableDeclarationList();
	if (Sym == C_SemicolonSym) {
		Get();
	}
_out_();
}

static void EmptyStatement(void)
{
_in_();
	Expect(C_SemicolonSym);
_out_();
}

static void LabelledStatement(void)
{
_in_();
	Expect(C_identifierSym);
	Expect(C_ColonSym);
	Statement();
_out_();
}

static void ExpressionStatement(void)
{
_in_();
	Expression();
	if (Sym == C_SemicolonSym) {
		Get();
	}
_out_();
}

static void IfStatement(void)
{
_in_();
	Expect(C_ifSym);
	Expect(C_LparenSym);
	Expression();
	Expect(C_RparenSym);
	Statement();
	if (Sym == C_elseSym) {
		Get();
		Statement();
	}
_out_();
}

static void IterationStatement(void)
{
_in_();
	switch (Sym) {
		case C_doSym:  
			Get();
			Statement();
			Expect(C_whileSym);
			Expect(C_LparenSym);
			Expression();
			Expect(C_RparenSym);
			if (Sym == C_SemicolonSym) {
				Get();
			}
			break;
		case C_whileSym:  
			Get();
			Expect(C_LparenSym);
			Expression();
			Expect(C_RparenSym);
			Statement();
			break;
		case C_forSym:  
			Get();
			Expect(C_LparenSym);
			if (Sym >= C_identifierSym && Sym <= C_stringSym ||
			    Sym >= C_regexD1Sym && Sym <= C_LparenSym ||
			    Sym >= C_nullSym && Sym <= C_LbrackSym ||
			    Sym == C_LbraceSym ||
			    Sym == C_newSym ||
			    Sym >= C_PlusPlusSym && Sym <= C_BangSym ||
			    Sym == C_functionSym) {
				ExpressionNoIn();
			}
			Expect(C_SemicolonSym);
			if (Sym >= C_identifierSym && Sym <= C_stringSym ||
			    Sym >= C_regexD1Sym && Sym <= C_LparenSym ||
			    Sym >= C_nullSym && Sym <= C_LbrackSym ||
			    Sym == C_LbraceSym ||
			    Sym == C_newSym ||
			    Sym >= C_PlusPlusSym && Sym <= C_BangSym ||
			    Sym == C_functionSym) {
				Expression();
			}
			Expect(C_SemicolonSym);
			if (Sym >= C_identifierSym && Sym <= C_stringSym ||
			    Sym >= C_regexD1Sym && Sym <= C_LparenSym ||
			    Sym >= C_nullSym && Sym <= C_LbrackSym ||
			    Sym == C_LbraceSym ||
			    Sym == C_newSym ||
			    Sym >= C_PlusPlusSym && Sym <= C_BangSym ||
			    Sym == C_functionSym) {
				Expression();
			}
			Expect(C_RparenSym);
			Statement();
			break;
		default: 
			Get();
			Expect(C_LparenSym);
			Expect(C_varSym);
			VariableDeclarationList();
			Expect(C_SemicolonSym);
			if (Sym >= C_identifierSym && Sym <= C_stringSym ||
			    Sym >= C_regexD1Sym && Sym <= C_LparenSym ||
			    Sym >= C_nullSym && Sym <= C_LbrackSym ||
			    Sym == C_LbraceSym ||
			    Sym == C_newSym ||
			    Sym >= C_PlusPlusSym && Sym <= C_BangSym ||
			    Sym == C_functionSym) {
				Expression();
			}
			Expect(C_SemicolonSym);
			if (Sym >= C_identifierSym && Sym <= C_stringSym ||
			    Sym >= C_regexD1Sym && Sym <= C_LparenSym ||
			    Sym >= C_nullSym && Sym <= C_LbrackSym ||
			    Sym == C_LbraceSym ||
			    Sym == C_newSym ||
			    Sym >= C_PlusPlusSym && Sym <= C_BangSym ||
			    Sym == C_functionSym) {
				Expression();
			}
			Expect(C_RparenSym);
			Statement();
			break;
		default: 
			Get();
			Expect(C_LparenSym);
			Expect(C_varSym);
			VariableDeclarationNoIn();
			Expect(C_inSym);
			Expression();
			Expect(C_RparenSym);
			Statement();
			break;
		default: 
			Get();
			Expect(C_LparenSym);
			LeftHandSideExpressionForIn();
			Expect(C_inSym);
			Expression();
			Expect(C_RparenSym);
			Statement();
			break;
		default :GenError(113); break;
	}
_out_();
}

static void ContinueStatement(void)
{
_in_();
	Expect(C_continueSym);
	if (Sym == C_identifierSym) {
		Get();
	}
	if (Sym == C_SemicolonSym) {
		Get();
	}
_out_();
}

static void BreakStatement(void)
{
_in_();
	Expect(C_breakSym);
	if (Sym == C_identifierSym) {
		Get();
	}
	if (Sym == C_SemicolonSym) {
		Get();
	}
_out_();
}

static void ImportStatement(void)
{
_in_();
	Expect(C_importSym);
	Name();
	if (Sym == C_PointSym) {
		Get();
		Expect(C_StarSym);
	}
	Expect(C_SemicolonSym);
_out_();
}

static void ReturnStatement(void)
{
_in_();
	Expect(C_returnSym);
	if (Sym >= C_identifierSym && Sym <= C_stringSym ||
	    Sym >= C_regexD1Sym && Sym <= C_LparenSym ||
	    Sym >= C_nullSym && Sym <= C_LbrackSym ||
	    Sym == C_LbraceSym ||
	    Sym == C_newSym ||
	    Sym >= C_PlusPlusSym && Sym <= C_BangSym ||
	    Sym == C_functionSym) {
		Expression();
	}
	if (Sym == C_SemicolonSym) {
		Get();
	}
_out_();
}

static void WithStatement(void)
{
_in_();
	Expect(C_withSym);
	Expect(C_LparenSym);
	Expression();
	Expect(C_RparenSym);
	Statement();
_out_();
}

static void SwitchStatement(void)
{
_in_();
	Expect(C_switchSym);
	Expect(C_LparenSym);
	Expression();
	Expect(C_RparenSym);
	CaseBlock();
_out_();
}

static void ThrowStatement(void)
{
_in_();
	Expect(C_throwSym);
	Expression();
	if (Sym == C_SemicolonSym) {
		Get();
	}
_out_();
}

static void TryStatement(void)
{
_in_();
	Expect(C_trySym);
	Block();
	if (Sym == C_finallySym) {
		Finally();
	} else if (Sym == C_catchSym) {
		Catch();
		if (Sym == C_finallySym) {
			Finally();
		}
	} else GenError(114);
_out_();
}

static void StatementList(void)
{
_in_();
	Statement();
	while (Sym >= C_identifierSym && Sym <= C_stringSym ||
	       Sym >= C_regexD1Sym && Sym <= C_LparenSym ||
	       Sym >= C_nullSym && Sym <= C_LbrackSym ||
	       Sym == C_LbraceSym ||
	       Sym == C_newSym ||
	       Sym >= C_PlusPlusSym && Sym <= C_BangSym ||
	       Sym >= C_varSym && Sym <= C_ifSym ||
	       Sym >= C_doSym && Sym <= C_switchSym ||
	       Sym >= C_throwSym && Sym <= C_trySym ||
	       Sym >= C_functionSym && Sym <= C_importSym) {
		Statement();
	}
_out_();
}

static void VariableDeclarationList(void)
{
_in_();
	VariableDeclaration();
	while (Sym == C_CommaSym) {
		Get();
		VariableDeclaration();
	}
_out_();
}

static void VariableDeclaration(void)
{
_in_();
	Expect(C_identifierSym);
	if (Sym == C_EqualSym) {
		Initialiser();
	}
_out_();
}

static void Initialiser(void)
{
_in_();
	Expect(C_EqualSym);
	AssignmentExpression();
_out_();
}

static void VariableDeclarationNoIn(void)
{
_in_();
	Expect(C_identifierSym);
	if (Sym == C_EqualSym) {
		InitialiserNoIn();
	}
_out_();
}

static void InitialiserNoIn(void)
{
_in_();
	Expect(C_EqualSym);
	AssignmentExpressionNoIn();
_out_();
}

static void CaseBlock(void)
{
_in_();
	Expect(C_LbraceSym);
	if (Sym == C_caseSym) {
		CaseClauses();
	}
	if (Sym == C_RbraceSym) {
		Get();
	} else if (Sym == C_defaultSym) {
		DefaultClause();
		if (Sym == C_caseSym) {
			CaseClauses();
		}
		Expect(C_RbraceSym);
	} else GenError(115);
_out_();
}

static void CaseClauses(void)
{
_in_();
	CaseClause();
	while (Sym == C_caseSym) {
		CaseClause();
	}
_out_();
}

static void DefaultClause(void)
{
_in_();
	Expect(C_defaultSym);
	Expect(C_ColonSym);
	if (Sym >= C_identifierSym && Sym <= C_stringSym ||
	    Sym >= C_regexD1Sym && Sym <= C_LparenSym ||
	    Sym >= C_nullSym && Sym <= C_LbrackSym ||
	    Sym == C_LbraceSym ||
	    Sym == C_newSym ||
	    Sym >= C_PlusPlusSym && Sym <= C_BangSym ||
	    Sym >= C_varSym && Sym <= C_ifSym ||
	    Sym >= C_doSym && Sym <= C_switchSym ||
	    Sym >= C_throwSym && Sym <= C_trySym ||
	    Sym >= C_functionSym && Sym <= C_importSym) {
		StatementList();
	}
_out_();
}

static void CaseClause(void)
{
_in_();
	Expect(C_caseSym);
	Expression();
	Expect(C_ColonSym);
	if (Sym >= C_identifierSym && Sym <= C_stringSym ||
	    Sym >= C_regexD1Sym && Sym <= C_LparenSym ||
	    Sym >= C_nullSym && Sym <= C_LbrackSym ||
	    Sym == C_LbraceSym ||
	    Sym == C_newSym ||
	    Sym >= C_PlusPlusSym && Sym <= C_BangSym ||
	    Sym >= C_varSym && Sym <= C_ifSym ||
	    Sym >= C_doSym && Sym <= C_switchSym ||
	    Sym >= C_throwSym && Sym <= C_trySym ||
	    Sym >= C_functionSym && Sym <= C_importSym) {
		StatementList();
	}
_out_();
}

static void Finally(void)
{
_in_();
	Expect(C_finallySym);
	Block();
_out_();
}

static void Catch(void)
{
_in_();
	Expect(C_catchSym);
	Expect(C_LparenSym);
	Expect(C_identifierSym);
	Expect(C_RparenSym);
	Block();
_out_();
}

static void FunctionDeclaration(void)
{
_in_();
	Expect(C_functionSym);
	Expect(C_identifierSym);
	Expect(C_LparenSym);
	if (Sym == C_identifierSym) {
		FormalParameterList();
	}
	Expect(C_RparenSym);
	FunctionBody();
_out_();
}

static void FormalParameterList(void)
{
_in_();
	Expect(C_identifierSym);
	while (Sym == C_CommaSym) {
		Get();
		Expect(C_identifierSym);
	}
_out_();
}

static void FunctionBody(void)
{
_in_();
	Expect(C_LbraceSym);
	if (Sym >= C_identifierSym && Sym <= C_stringSym ||
	    Sym >= C_regexD1Sym && Sym <= C_LparenSym ||
	    Sym >= C_nullSym && Sym <= C_LbrackSym ||
	    Sym == C_LbraceSym ||
	    Sym == C_newSym ||
	    Sym >= C_PlusPlusSym && Sym <= C_BangSym ||
	    Sym >= C_varSym && Sym <= C_ifSym ||
	    Sym >= C_doSym && Sym <= C_switchSym ||
	    Sym >= C_throwSym && Sym <= C_trySym ||
	    Sym >= C_functionSym && Sym <= C_importSym) {
		SourceElements();
	}
	Expect(C_RbraceSym);
_out_();
}

static void SourceElement(void)
{
_in_();
	if (Sym == C_functionSym) {
		FunctionDeclaration();
	} else if (Sym >= C_identifierSym && Sym <= C_stringSym ||
	           Sym >= C_regexD1Sym && Sym <= C_LparenSym ||
	           Sym >= C_nullSym && Sym <= C_LbrackSym ||
	           Sym == C_LbraceSym ||
	           Sym == C_newSym ||
	           Sym >= C_PlusPlusSym && Sym <= C_BangSym ||
	           Sym >= C_varSym && Sym <= C_ifSym ||
	           Sym >= C_doSym && Sym <= C_switchSym ||
	           Sym >= C_throwSym && Sym <= C_trySym ||
	           Sym == C_importSym) {
		Statement();
	} else GenError(116);
_out_();
}

static void Name(void)
{
_in_();
	Expect(C_identifierSym);
	while (Sym == C_PointSym) {
		Get();
		Expect(C_identifierSym);
	}
_out_();
}

static void JScriptVarDeclarationList(void)
{
_in_();
	JScriptVarDeclaration();
	while (Sym == C_CommaSym) {
		Get();
		JScriptVarDeclaration();
	}
_out_();
}

static void JScriptVarDeclaration(void)
{
_in_();
	Expect(C_identifierSym);
	Expect(C_ColonSym);
	Expect(C_identifierSym);
	if (Sym == C_EqualSym) {
		Initialiser();
	}
_out_();
}



//void cParser::Parse()
//{ Scanner->Reset(); Get();
//  C();
//}
